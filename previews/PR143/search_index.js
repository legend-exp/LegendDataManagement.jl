var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"Order = [:module]","category":"section"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"Order = [:type, :constant]","category":"section"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"Order = [:macro, :function]","category":"section"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#LegendDataManagement.AbstractSetupData","page":"API","title":"LegendDataManagement.AbstractSetupData","text":"abstract type AbstractSetupData\n\nSubtypes wrap SetupConfig for specific experiments.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ChannelId","page":"API","title":"LegendDataManagement.ChannelId","text":"struct ChannelId <: DataSelector\n\nRepresents a LEGEND data channel.\n\nExample:\n\nch = ChannelId(1083204)\n# ch = ChannelId(98) # with old channel numbering\nch.no == 1083204\nstring(ch) == \"ch1083204\"\nChannelId(\"ch1083204\") == ch\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataCategory","page":"API","title":"LegendDataManagement.DataCategory","text":"struct DataCategory <: DataSelector\n\nRepresents a LEGEND data category (related to a DAQ/measuring mode) like \"cal\" or \"phy\".\n\nExample:\n\ncategory = DataCategory(:cal)\ncategory.label == :cal\nstring(category) == \"cal\"\nDataCategory(\"cal\") == category\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPartition","page":"API","title":"LegendDataManagement.DataPartition","text":"struct DataPartition <: DataSelector\n\nRepresents a LEGEND data-taking partition. If only a number is given, the struct uses category :cal and set :a as default.  \n\nThe struct can also be constructed from strings in various formats, such as \"calgroup001a\", \"calpartition001a\", \"calpart001a\", or the short form \"part001\".\n\nExample:\n\npartition = DataPartition(1)\npartition.cat == :cal\npartition.no == 1\npartition.set == :a\nstring(partition) == \"calpartition001a\"\nDataPartition(\"calgroup001a\") == partition\nDataPartition(\"calpart001a\") == partition\nDataPartition(\"part001\") == partition\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPeriod","page":"API","title":"LegendDataManagement.DataPeriod","text":"struct DataPeriod <: DataSelector\n\nRepresents a LEGEND data-taking period.\n\nExample:\n\nperiod = DataPeriod(2)\nperiod.no == 2\nstring(period) == \"p02\"\nDataPeriod(\"p02\") == period\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataRun","page":"API","title":"LegendDataManagement.DataRun","text":"struct DataRun <: DataSelector\n\nRepresents a LEGEND data-taking run.\n\nExample:\n\nr = DataRun(6)\nr.no == 6\nstring(r) == \"r006\"\nDataRun(\"r006\") == r\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataSelector","page":"API","title":"LegendDataManagement.DataSelector","text":"abstract type DataSelector\n\nAbstract type for data selectors like ExpSetup, DataTier, DataPeriod, DataRun, DataCategory, Timestamp and FileKey.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataTier","page":"API","title":"LegendDataManagement.DataTier","text":"struct DataTier <: DataSelector\n\nRepresents a LEGEND data tier like \"raw, \"dsp\", etc.\n\nExample:\n\ntier = DataTier(:raw)\ntier.label == :raw\nstring(tier) == \"raw\"\nDataTier(\"raw\") == tier\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DetectorId","page":"API","title":"LegendDataManagement.DetectorId","text":"struct DetectorId <: DataSelector\n\nRepresents a LEGEND detector id id.\n\nExample:\n\ndetector = DetectorId(:V99000A)\ndetector.label == :V99000A\nstring(detector) == \"V99000A\"\nDetectorId(\"V99000A\") == detector\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ExpSetup","page":"API","title":"LegendDataManagement.ExpSetup","text":"struct ExpSetup <: DataSelector\n\nRepresents a LEGEND experimental setup like \"l200\".\n\nExample:\n\nsetup = ExpSetup(:l200)\nsetup.label == :l200\nstring(setup) == \"l200\"\nExpSetup(\"l200\") == setup\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.FileKey","page":"API","title":"LegendDataManagement.FileKey","text":"struct FileKey <: DataSelector\n\nRepresents a LEGEND file key.\n\nExample:\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nSee also read_filekeys and write_filekeys.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendData","page":"API","title":"LegendDataManagement.LegendData","text":"struct LegendData <: AbstractSetupData\n\nProvides access to LEGEND data and metadata.\n\nConstructors:\n\nLegendData(setup_config::SetupConfig).\nLegendData(setup::Symbol) - requires the $LEGEND_DATA_CONFIG environment variable to be set.\n\nExamples:\n\nconfig_filename = \"/path/to/config.json\"\nconfig = LegendDataConfig(config_filename)\nl200 = LegendData(config.setups.l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nor simply (if $LEGEND_DATA_CONFIG is set):\n\nl200 = LegendData(:l200)\n\nLegendData has the (virtual) properties metadata and tier.\n\nThe full path to \"tier\" data files can be retrieved using\n\n(data::LegendData)[tier::Symbol, filekey::FileKey]\n(data::LegendData).tier[tier::Symbol, filekey::AbstractString]\n\nExample:\n\nl200.tier[:raw]\nl200.tier[:raw, FileKey(\"l200-p02-r006-cal-20221226T200846Z\")]\n\nLegendData comes with an extension for SolidStateDetectors:\n\nl200 = LegendData(:l200)\nSolidStateDetector(l200, :V99000A)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendDataConfig","page":"API","title":"LegendDataManagement.LegendDataConfig","text":"struct LegendDataConfig\n\nData configuration multiple experimental setups.\n\nContains a single field setups::PropertyDict{Symbol,SetupConfig}.\n\nCan be read from a config file via LegendDataConfig(config_filename[s]), or simply LegendDataConfig() if the environment variable $LEGEND_DATA_CONFIG is set. $LEGEND_DATA_CONFIG may be a list of colon-separated config filenames, which are applied/merged in reverse order (analog to the order of prioritiy in $PATH and similar).\n\nExample:\n\nconfig = LegendDataConfig(\"/path/to/config.json\")\nsetup = config.setups.l200\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\nSee also SetupConfig.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendReport","page":"API","title":"LegendDataManagement.LegendReport","text":"struct LegendReport\n\nRepresents a LEGEND report.\n\nDon't instantiate directly, use lreport()\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendTierData","page":"API","title":"LegendDataManagement.LegendTierData","text":"struct LegendDataManagement.LegendTierData\n\nConstructors:\n\n(data::LegendData).tier\n\nLegendDataManagement.LegendTierData(data::LegendData)\n\nThe path to data directories and files can be accessed via getindex on tier_data::LegendTierData:\n\ntier_data[]\ntier_data[tier::DataTierLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike, ch::ChannelIdLike]\n\ntier_data[tier::DataTierLike, filekey::FileKeyLike]\ntier_data[tier::DataTierLike, filekey::FileKeyLike, ch::ChannelIdLike]\n\nExamples:\n\n```julia l200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\") isfile(l200.tier[:raw, filekey])\n\nisdir(l200.tier[:raw, :cal]) isdir(l200.tier[:raw, :cal, \"p02\"]) isdir(l200.tier[:raw, :cal, \"p02\", \"r006\"]) isdir(l200.tier[DataTier(:raw), DataCategory(:cal), DataPeriod(2), DataRun(6)])\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.NoSuchPropsDBEntry","page":"API","title":"LegendDataManagement.NoSuchPropsDBEntry","text":"struct LegendDataManagement.NoSuchPropsDBEntry\n\nIndicates that a given property (path) of a LegendDataManagementPropsDB[@ref] does not exist.\n\nSupports PropDicts.writeprops(missing_props::NoSuchPropsDBEntry, props::PropDicts.PropDict) to create the missing directories and file for the property path.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.PeriodSelLike","page":"API","title":"LegendDataManagement.PeriodSelLike","text":"struct PeriodSelLike = Tuple{<:DataPeriodLike, <:DataCategoryLike}\n\nRepresents a LEGEND period selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ProcessStatus","page":"API","title":"LegendDataManagement.ProcessStatus","text":"@enum ProcessStatus\n\nMay be succeeded, pending, or failed.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.PropsDB","page":"API","title":"LegendDataManagement.PropsDB","text":"struct LegendDataManagement.PropsDB\n\nA PropsDB instance, e.g. myprops, presents an on-disk directory containing JSON files or sub-directories (that contains JSON files in leaf directories) as a dictionary of properties.\n\nPropsDB supports Base.keys and Base.getindex as well as Base.propertynames and Base.getproperty to access it's contents. getindex and getproperty will return either another PropsDB or a PropDicts.PropDict, depending on whether the accessed property is stored as a sub-directory or a JSON file. We recommend to use getproperty where the properties/keys of the PropDict are more or less standardized and where they may be arbitrary (see examples below).\n\nThe contents of PropsDB may be time- and category-dependent, determined by the presence of a \"validity.json\" file. In this case, use myprops(sel::LegendDataManagement.ValiditySelection) or myprops(filekey::FileKey) to select the desired time and category. The selection can be made at some point during traversal of properties or at the leaf PropsDB (see the examples below).\n\nExamples:\n\nl200 = LegendData(:l200)\n\npropertynames(l200.metadata.hardware)\nl200.metadata.hardware.detectors.germanium\n\nkeys(l200.metadata.hardware.detectors.germanium.diodes)\nl200.metadata.hardware.detectors.germanium.diodes[:V99000A]\n\ndiodes = l200.metadata.hardware.detectors.germanium.diodes\ndiodes[keys(diodes)]\n\nsel = ValiditySelection(\"20221226T194007Z\", :cal)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T194007Z\")\ndata.metadata.hardware(sel).configuration.channelmaps\ndata.metadata.hardware.configuration.channelmaps(filekey)\n\nUse code should not instantiate PropsDB directly, use  LegendDataManagement.AnyProps(path::AbstractString) instead, which may return a PropsDB or a PropDicts.PropDict depending on what on-disk content path points to. \n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.RunCategorySelLike","page":"API","title":"LegendDataManagement.RunCategorySelLike","text":"struct RunCategorySelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.RunSelLike","page":"API","title":"LegendDataManagement.RunSelLike","text":"struct RunSelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.SetupConfig","page":"API","title":"LegendDataManagement.SetupConfig","text":"struct SetupConfig\n\nData configuration for an experimental setup.\n\nSupports\n\ndata_path(setup, path_components)\n\nExamples:\n\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.Timestamp","page":"API","title":"LegendDataManagement.Timestamp","text":"struct Timestamp <: DataSelector\n\nRepresents a LEGEND timestamp.\n\nExample:\n\njulia timestamp = Timestamp(\"20221226T200846Z\") timestamp.unixtime == 1672085326 string(timestamp) == \"20221226T200846Z\"`\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ValiditySelection","page":"API","title":"LegendDataManagement.ValiditySelection","text":"struct LegendDataManagement.ValiditySelection\n\nRepresenty validiy selection for a LegendDataManagement.PropsDB[@ref].\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.AnyProps","page":"API","title":"LegendDataManagement.AnyProps","text":"LegendDataManagement.AnyProps = Union{LegendDataManagement.PropsDB,PropDicts.PropDict}\n\nProperties stored either in a directory managed via [LegendDataManagement.PropsDB][@ref] or loaded from one or several files into a PropDicts.PropDict.\n\nConstructors:\n\nLegendDataManagement.AnyProps(base_path::AbstractString; override_base::AbstractString = \"\")\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.AnyValiditySelection","page":"API","title":"LegendDataManagement.AnyValiditySelection","text":"const AnyValiditySelection = Union{ValiditySelection,FileKey}\n\nAnything that can be used in time/category-based data selection.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ChannelIdLike","page":"API","title":"LegendDataManagement.ChannelIdLike","text":"ChannelIdLike = Union{ChannelId, Integer, AbstractString}\n\nAnything that can represent a data channel, like ChannelId(1083204) or \"ch1083204\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataCategoryLike","page":"API","title":"LegendDataManagement.DataCategoryLike","text":"DataCategoryLike = Union{DataCategory, Symbol, AbstractString}\n\nAnything that can represent a data category, like DataCategory(:cal), :cal or \"cal\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPartitionLike","page":"API","title":"LegendDataManagement.DataPartitionLike","text":"DataPartitionLike = Union{DataPartition, Symbol, AbstractString}\n\nAnything that can represent a data partition, like DataPartition(:calgroup001a) or \"part02\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPeriodLike","page":"API","title":"LegendDataManagement.DataPeriodLike","text":"DataPeriodLike = Union{DataPeriod, Symbol, AbstractString}\n\nAnything that can represent a data period, like DataPeriod(2) or \"p02\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataRunLike","page":"API","title":"LegendDataManagement.DataRunLike","text":"DataRunLike = Union{DataRun, Symbol, AbstractString}\n\nAnything that can represent a data run, like DataRun(6) or \"r006\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataTierLike","page":"API","title":"LegendDataManagement.DataTierLike","text":"DataTierLike = Union{DataTier, Symbol, AbstractString}\n\nAnything that can represent a data tier, like DataTier(:raw), :raw or \"raw\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DetectorIdLike","page":"API","title":"LegendDataManagement.DetectorIdLike","text":"DetectorIdLike = Union{DetectorId, Symbol, AbstractString}\n\nAnything that can represent a detector id.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ExpSetupLike","page":"API","title":"LegendDataManagement.ExpSetupLike","text":"ExpSetupLike = Union{ExpSetup, Symbol, AbstractString}\n\nAnything that can represent a setup label, like ExpSetup(:l200), :l200 or \"l200\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.FileKeyLike","page":"API","title":"LegendDataManagement.FileKeyLike","text":"FileKeyLike = Union{FileKey, AbstractString}\n\nAnything that can represent a file key, like FileKey(\"l200-p02-r006-cal-20221226T200846Z\") or \"l200-p02-r006-cal-20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LJlExprLike","page":"API","title":"LegendDataManagement.LJlExprLike","text":"const LJlExprLike = Union{Expr, Symbol, Integer, AbstractFloat}\n\nAnything that can represent a parsed LEGEND Julia expression.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.TimestampLike","page":"API","title":"LegendDataManagement.TimestampLike","text":"TimestampLike = Union{Timestamp, AbstractString, Integer}\n\nAnything that can represent a timestamp, like Timestamp(\"20221226T200846Z\") or \"20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.analysis_runs-Tuple{LegendData, DataCategoryLike}","page":"API","title":"LegendDataManagement.analysis_runs","text":"analysis_runs(data::LegendData)\n\nReturn cross-period analysis runs. Picks the dataset specified in data.dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.atomic_fcreate-Tuple{Any, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.atomic_fcreate","text":"function atomic_fcreate(\n    body, filenames::AbstractString...;\n    create_dirs::Bool = true, overwrite::Bool = true, delete_on_error::Bool=true\n)\n\nCreates filenames in an atomic fashion.\n\nCreates temporary files in the same directories as filenames, then calls body(temporary_filenames...). If body returns successfully, the files temporary_filenames are renamed to filenames. If body throws an exception, the temporary files are either deleted (if delete_on_error is true) or left in place (e.g. for debugging purposes).\n\nIf create_dirs is true, directories are created if necessary.\n\nIf all of files already exist and overwrite is false, takes no action (or, if the file is created by other code running in parallel, while body is running, does not overwrite it).\n\nThrows an error if only some of the files exist and overwrite is false.\n\nReturns nothing.\n\nExample:\n\natomic_fcreate(\"foo.txt\", \"bar.txt\") do foo, bar\n    write(foo, \"Hello\")\n    write(bar, \"World\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.bad_filekeys-Tuple{LegendData}","page":"API","title":"LegendDataManagement.bad_filekeys","text":"bad_filekeys(data::LegendData, load_key::Symbol=:all)\n\nGet the list of filekeys to ignore for data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.cal_groupings_default-Tuple{LegendData}","page":"API","title":"LegendDataManagement.cal_groupings_default","text":"cal_groupings_default(data::LegendData)\n\nReturns default cal_groupings runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.channelinfo-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection; system::Symbol = :all, only_processable::Bool = false, only_usability::Symbol = :all, extended::Bool = false)\nchannelinfo(data::LegendData, sel::RunCategorySelLike; system::Symbol = :all, only_processable::Bool = false, only_usability::Symbol = :all, extended::Bool = false)\n\nGet all channel information for the given LegendData and ValiditySelection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path","page":"API","title":"LegendDataManagement.data_path","text":"data_path(setup::SetupConfig, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\nConverts between \"/\" and \"\\\" inside of path_components if necessary (for Windows compatibility).\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.AbstractSetupData, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(setup::AbstractSetupData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.LegendTierData, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(tier_data::LegendTierData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components relative to tier_data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.PropsDB}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(pd::LegendDataManagement.PropsDB)\n\nReturn the path to the data directory that contains pd.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_config-Tuple{LegendData}","page":"API","title":"LegendDataManagement.dataprod_config","text":"dataprod_config(data::LegendData)\n\nGet the Julia data production configuration for data.\n\nUse dataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\ndataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\ndataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_parameters-Tuple{LegendData}","page":"API","title":"LegendDataManagement.dataprod_parameters","text":"dataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_pars_aoe_window-Tuple{LegendData, AnyValiditySelection, DetectorId, Symbol}","page":"API","title":"LegendDataManagement.dataprod_pars_aoe_window","text":"LegendDataManagement.dataprod_pars_aoe_window(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the A/E cut window for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_pars_lq_window-Tuple{LegendData, AnyValiditySelection, DetectorId, Symbol}","page":"API","title":"LegendDataManagement.dataprod_pars_lq_window","text":"LegendDataManagement.dataprod_pars_lq_window(data::LegendData, sel::AnyValiditySelection, detector::DetectorId, lq_classifier::Symbol; pars_type::Symbol=:ppars, pars_cat::Symbol=:lq)\n\nGet the LQ cut window for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.find_filekey","page":"API","title":"LegendDataManagement.find_filekey","text":"find_filekey(ds::DataSet, ts::TimestampLike)\nfind_filekey(data::LegendData, ts::TimestampLike; kwargs...)\n\nFind the filekey in a dataset that is closest to a given timestamp. The kwargs are passed to search_disk to generate the DataSet.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_aux_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_aux_cal_propfunc","text":"get_aux_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the aux calibration function for the given data, validity selection and the aux channel referred to by detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_aux_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_aux_evt_chdata_propfunc","text":"get_aux_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the aux channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_aux_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_aux_evt_chsel_propfunc","text":"get_aux_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the aux channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_aux_evt_levelname_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_aux_evt_levelname_propfunc","text":"get_aux_evt_levelname_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the aux event level name.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_exposure-Tuple{LegendData, DetectorIdLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}}","page":"API","title":"LegendDataManagement.get_exposure","text":"get_exposure(data::LegendData, det::DetectorIdLike, period::DataPeriodLike, run::DataRunLike; kwargs...)\nget_exposure(data::LegendData, det::DetectorIdLike, period::DataPeriodLike; kwargs...)\nget_exposure(data::LegendData, det::DetectorIdLike, partition::DataPartitionLike; kwargs...)\n\nCalculates the exposure of a detector in a given run/period/partition.\n\nArguments\n\ndata: LegendData object with information on detector geometries and runinfo / partitioninfo\ndet Detector for which the exposure is calculated\nperiod: DataPeriod for which the exposure is calculated\nrun: DataRun for which the exposure is calculated\npartition: DataPartition for which the exposure is calculated\n\nKeyword Arguments\n\nis_analysis_run: If set to true, only the runs flagged as is_analysis_phy_tun == true are considered. Default is true.\ncat DataCategory for which the exposure is calculated. Default is :phy.`\n\nReturns\n\nexposure: the exposure of the detector det for the time given.\n\nExample\n\njulia l200 = LegendData(:l200) get_exposure(l200, :V00050A, DataPeriod(3), DataRun(0)) get_exposure(l200, :V00050A, DataPeriod(3)) get_exposure(l200, :V00050A, DataPartition(:calgroup001a))`\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_aoe_cut_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_aoe_cut_propfunc","text":"LegendDataManagement.get_ged_aoe_cut_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId; pars_type::Symbol=:ppars, pars_cat::Symbol=:aoe)\n\nGet the A/E cut propfuncs for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_cal_propfunc","text":"get_ged_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the HPGe calibration function for the given data, validity selection and detector.\n\nNote: Caches configuration/calibration data internally, use a fresh data object if on-disk configuration/calibration data may have changed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_chdata_propfunc","text":"get_ged_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the Ge-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_chsel_propfunc","text":"get_ged_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the Ge-detector channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_hitchsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_hitchsel_propfunc","text":"get_ged_evt_hitchsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the hit Ge-detector channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_is_valid_hit_properties-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_is_valid_hit_properties","text":"get_ged_evt_is_valid_hit_properties(data::LegendData, sel::AnyValiditySelection)\n\nGet the hit Ge-detector is_valid_hit selection properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_kwargs-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_kwargs","text":"get_ged_evt_kwargs(data::LegendData, sel::AnyValiditySelection)\n\nGet the Ge-detector evt kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_lq_cut_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_lq_cut_propfunc","text":"LegendDataManagement.get_ged_lq_cut_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId; pars_type::Symbol=:ppars, pars_cat::Symbol=:lq)\n\nGet the LQ cut propfuncs for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_psd_classifier_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_psd_classifier_propfunc","text":"get_ged_psd_classifier_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PSD cut propfuncs for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_psd_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_psd_propfunc","text":"get_ged_psd_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId; pars_type::Symbol=:ppars, pars_cat::Symbol=:aoe)\n\nGet the HPGe psd calibration function for the given data, validity selection and detector.\n\nNote: Caches configuration/calibration data internally, use a fresh data object if on-disk configuration/calibration data may have changed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_cuts_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_cuts_propfunc","text":"get_ged_qc_cuts_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector QC cut definitions for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_is_baseline_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_is_baseline_propfunc","text":"get_ged_qc_is_baseline_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet a PropertyFunction that returns true for events that fullfill the is_baseline definition.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_is_physical_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_is_physical_propfunc","text":"get_ged_qc_is_physical_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet a PropertyFunction that returns true for events that fullfill the is_physical definition.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_is_trig_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_is_trig_propfunc","text":"get_ged_qc_istrig_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector trigger condition for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_partition_combined_periods-Tuple{LegendData, DataPeriodLike}","page":"API","title":"LegendDataManagement.get_partition_combined_periods","text":"get_partition_combined_periods(data::LegendData, period::DataPeriodLike; chs::Vector{<:ChannelIdLike}=ChannelIdLike[])\nget_partition_combined_periods(data::LegendData, period::DataPeriodLike; dets::Vector{<:DetectorIdLike}=DetectorIdLike[])\n\nGet a list periods which are combined in any partition for the given period and list of channels.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmt_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_pmt_cal_propfunc","text":"get_pmt_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the PMT calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmt_is_physical_trig_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_pmt_is_physical_trig_propfunc","text":"get_pmt_is_physical_trig_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the PMT physical trigger condition for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_chdata_propfunc","text":"get_pmts_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_chsel_propfunc","text":"get_pmts_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_evtdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_evtdata_propfunc","text":"get_pmts_evt_evtdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_kwargs-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_kwargs","text":"get_pmts_evt_kwargs(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT evt kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_muon_cut_props-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_muon_cut_props","text":"get_pmts_evt_muon_cut_props(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT muon cut properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_setup_config","page":"API","title":"LegendDataManagement.get_setup_config","text":"LegendDataManagement.get_setup_config(data::AbstractSetupData)::SetupConfig\n\nMust be specialized for each subtype of AbstractSetupData.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_spm_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_spm_cal_propfunc","text":"get_spm_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spm_dc_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_spm_dc_cal_propfunc","text":"get_spm_dc_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS DC calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spm_dc_sel_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_spm_dc_sel_propfunc","text":"get_spm_dc_sel_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS DC calibration selector function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_chdata_propfunc","text":"get_spms_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_chsel_propfunc","text":"get_spms_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_kwargs-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_kwargs","text":"get_spms_evt_kwargs(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM-detector evt kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_lar_cut_props-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_lar_cut_props","text":"get_spms_evt_lar_cut_props(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM LAr cut properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_uncertainties","page":"API","title":"LegendDataManagement.get_uncertainties","text":"get_uncertainties(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_uncertainties(x::Unitful.Quantity{<:Real})\nget_uncertainties(pd::PropDict)\nget_uncertainties(A::AbstractArray)\n\nGet the uncertainty of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_values","page":"API","title":"LegendDataManagement.get_values","text":"get_values(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_values(x::Unitful.Quantity{<:Real})\nget_values(pd::PropDict)\nget_values(A::AbstractArray)\n\nGet the value of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.is_analysis_cal_run-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}}}","page":"API","title":"LegendDataManagement.is_analysis_cal_run","text":"is_analysis_cal_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike))\n\nReturn true if run is an analysis run for data in period. \n\nATTENTION: This is only valid for cal runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.is_analysis_phy_run-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}}}","page":"API","title":"LegendDataManagement.is_analysis_phy_run","text":"is_analysis_phy_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike))\n\nReturn true if run is an analysis run for data in period. \n\nATTENTION: This is only valid for phy runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.is_analysis_run","page":"API","title":"LegendDataManagement.is_analysis_run","text":"is_analysis_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike, cat::DataCategoryLike))\n\nReturn true if run is an cat analysis run for data in period.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.is_lrun-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"API","title":"LegendDataManagement.is_lrun","text":"is_lrun(data::LegendData, runsel::RunSelLike)\n\nReturn true if runsel is a valid run for data and therefore appears in the metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.livetime","page":"API","title":"LegendDataManagement.livetime","text":"livetime(data::LegendData, runsel::RunSelLike)\n\nGet the livetime for data in physics data taking of run in period.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.ljl_propfunc","page":"API","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr::LJlExprLike)\nljl_propfunc(expr_string::AbstractString)\n\nCompiles a PropertyFunctions.PropertyFunction from a LEGEND Julia expression.\n\nSee also parse_lpyexpr.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.ljl_propfunc-Tuple{AbstractDict{Symbol, <:Union{AbstractFloat, Expr, Integer, Symbol}}}","page":"API","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr_map::AbstractDict{Symbol,<:LJlExprLike})\nljl_propfunc(expr_map::AbstractDict{Symbol,<:AbstractString})\nljl_propfunc(expr_map::PropDict)\n\nCompiles a map between output field-names and LEGEND Julia expressions to a single PropertyFunctions.PropertyFunction.\n\nThe generated function will return NamedTuples with the same property names as the keys of expr_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.lpy_propfunc-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.lpy_propfunc","text":"lpy_propfunc(expr_string::AbstractString)::PropertyFunctions.PropertyFunction\n\nGenerate a PropertyFunctions.PropertyFunction from a LEGEND Python expression.\n\nSee also parse_lpyexpr and ljl_propfunc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.lreport","page":"API","title":"LegendDataManagement.lreport","text":"lreport()\nlreport(contents...)\n\nGenerate a LEGEND report, e.g. a data processing report.\n\nUse lreport!(rpt, contents...) to add more content to a report.\n\nExample:\n\nusing LegendDataManagement, StructArrays, IntervalSets, Plots\n\ntbl = StructArray(\n    col1 = rand(5), col2 = ClosedInterval.(rand(5), rand(5).+1),\n    col3 = [rand(3) for i in 1:5], col4 = ProcessStatus.(rand(-1:1, 5)),\n    col5 = [:a, :b, :c, :d, :e], col6 = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    col7 = [:(a[1]), :(a[2]), :(a[3]), :(a[4]), :(a[5])]\n)\n\nrpt = lreport(\n    \"# New report\",\n    \"Table 1:\", tbl\n)\nlreport!(rpt, \"Figure 1:\", stephist(randn(10^3)))\nlreport!(rpt, \"Figure 2:\", histogram2d(randn(10^4), randn(10^4), format = :png))\n\nshow(stdout, MIME\"text/plain\"(), rpt)\nshow(stdout, MIME\"text/html\"(), rpt)\nshow(stdout, MIME\"text/markdown\"(), rpt)\n\nwritelreport(\"report.txt\", rpt)\nwritelreport(\"report.html\", rpt)\nwritelreport(\"report.md\", rpt)\n\nSee LegendDataManagement.lreport_for_show! for how to specialize the behavior of show for specific report content types.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.lreport!","page":"API","title":"LegendDataManagement.lreport!","text":"lreport!(rpt::LegendReport, contents...)\n\nAdd more content to report rpt. See lreport for an example.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.lreport_for_show!","page":"API","title":"LegendDataManagement.lreport_for_show!","text":"LegendDataManagement.lreport_for_show!(rpt::LegendReport, mime::MIME, content)\n\nAdd the contents of content to rpt in a way that is optimized for being displayed (e.g. via show) with the given mime type.\n\nshow(output, mime, rpt) first transforms rpt by converting all contents of rpt using lreport_for_show!(rpt::LegendReport, mime, content).\n\nDefaults to lreport!(rpt, content), except for tables (Tables.istable(content) == true), which are converted to Markdown tables by default for uniform appearance.\n\nlreport_for_show! is not inteded to be called by users, but to be specialized for specific types of content content. Content types not already supported will primarily require specialization of\n\nlreport_for_show!(rpt::LegendReport, ::MIME\"text/markdown\", content::SomeType)\n\nIn some cases it may be desireable to specialize lreport_for_show! for MIME types like MIME\"text/html\" and MIME\"text/plain\" as well.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.map_datafiles-Tuple{Any, Any, LegendData, DataCategoryLike, AbstractVector{<:FileKey}}","page":"API","title":"LegendDataManagement.map_datafiles","text":"map_datafiles(\n    f_process, f_open, data::LegendData,\n    category::DataCategoryLike, filekeys::AbstractVector{<:FileKey}\n)\n\nProcesses all filekeys in data for category.\n\nOpens the files using f_open and processes them using f_process.\n\nReturns a @NamedTuple{result::Dict{Filekey}, failed::Dict{Filekey}, success::Bool}:\n\nvalues(result) contains the results f_process(f_open(filename)) for  all filenames referred to by category and filekeys.\nvalues(result) contains the error where processing failed.\nsuccess equals isempty(failed)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.parse_ljlexpr-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.parse_ljlexpr","text":"parse_ljlexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an LEGEND Julia expression and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.parse_lpyexpr-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.parse_lpyexpr","text":"parse_lpyexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an expression compatible with the LEGEND Python software and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.parse_runs-Tuple{AbstractVector{<:AbstractString}}","page":"API","title":"LegendDataManagement.parse_runs","text":"parse_runs(::AbstractVector{<:AbstractString})::Vector{DataRun}\nparse_runs(::AbstractString})::Vector{DataRun}\n\nParse a String or a Vector{String} of runs in the format \"rXXX\" (single run) or \"rXXX..rYYY\" (range of runs).\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.partitioninfo","page":"API","title":"LegendDataManagement.partitioninfo","text":"partitioninfo(data::LegendData, det::DetectorIdLike, cat::DataCategoryLike)\npartitioninfo(data, det, part::DataPartition)\npartitioninfo(data, det, cat, period::DataPeriod)\npartitioninfo(data, det, cat, period, run)\n\npartitioninfo(data::LegendData, ch::ChannelId, cat::DataCategoryLike = :cal)\n\nReturn cross-period data partitions.\n\nArguments\n\ndata::LegendData: The LegendData object containing the data.\ndet::DetectorIdLike: The ID of the detector.\ncategory::DataCategoryLike: Analysis category to select groupings, e.g. :cal, :phy.\n\nReturns\n\nIdDict{DataPartition, Table}: A dictionary mapping data partitions to tables.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.phy_groupings_default-Tuple{LegendData}","page":"API","title":"LegendDataManagement.phy_groupings_default","text":"phy_groupings_default(data::LegendData)\n\nReturns default phy_groupings runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.process_ljlexpr","page":"API","title":"LegendDataManagement.process_ljlexpr","text":"process_ljlexpr(expr::LJlExprLike, f_varsubst = identity)::LJlExprLike\n\nVerify that expr is a valid LEGEND Julia expression and return it, with modifications if necessary.\n\nOptionally substitute variables in expr using f_varsubst.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.pydataprod_config-Tuple{LegendData}","page":"API","title":"LegendDataManagement.pydataprod_config","text":"pydataprod_config(data::LegendData)\n\nGet the Python data production configuration for data.\n\nUse pydataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\npydataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\npydataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.pydataprod_parameters-Tuple{LegendData}","page":"API","title":"LegendDataManagement.pydataprod_parameters","text":"pydataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.read_filekeys-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.read_filekeys","text":"read_filekeys(filename::AbstractString)::AbstractVector{FileKey}\n\nReads a list of FileKey from a text file, one file key per line.\n\nIgnores empty lines. # may be used to start a comment in the file.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.read_ldata","page":"API","title":"LegendDataManagement.read_ldata","text":"read_ldata(data::LegendData, selectors...; kwargs...)\nread_ldata(f, data::LegendData, selectors...; kwargs...)\nread_ldata(columns::NTuple{<:Any, Symbol}, data::LegendData, selectors::Tuple; kwargs...)\nread_ldata(column::Symbol, data::LegendData, selectors::Tuple; kwargs...)\n\nRead lh5 data from disk for a given set of selectors. After reading in, a PropertyFunction f can be applied to the data.  If a tuple of Symbols is given, the properties from the tuple are selected. If the n_evts kwarg is provided, a random selection with n_evts number of events per file is performed. ch can be either a ChannelId or a DetectorId.\n\nExamples\n\ndsp = read_ldata(l200, :jldsp, filekey, ch)\ndsp = read_ldata((:e_cusp, :e_trap, :blmean), l200, :jldsp, filekey, ch)\ndsp = read_ldata(:e_cusp, l200, :jldsp, filekey, ch)\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, ch)\n\ndsp = read_ldata(l200, :jldsp, :cal, DataPartition(:calgroup001a), ch)\ndsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch)\ndsp = read_ldata(l200, :jldsp, :cal, runinfo(l200)[1:3], ch)\n\ndsp = read_ldata(l200, :jldsp, filekey, ch; n_evts=1000)\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.readlprops","page":"API","title":"LegendDataManagement.readlprops","text":"readlprops(filename::AbstractString)\nreadlprops(filenames::Vector{<:AbstractString})\n\nRead a PropDict from a file and parse it to Unitful.Quantity and Measurements.Measurement objects.\n\nReturns\n\npd::PropDict with all :val fields converted to Unitful.Quantity objects and all :val fields converted to Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.runinfo-Tuple{LegendData}","page":"API","title":"LegendDataManagement.runinfo","text":"runinfo(data::LegendData)::Table\nruninfo(data::LegendData, runsel::RunSelLike)::NamedTuple\nruninfo(data::LegendData, filekey::FileKey)::NamedTuple\n\nGet the run information for data based on various selection criteria.\n\nArguments\n\ndata::LegendData: The dataset to query run information from.\n\nReturns\n\nA table of run information with one named tuple per category (e.g. :cal, :phy), each containing startkey, livetime, and is_analysis_run\n\nExample\n\nruninfo(data)                                   # full table of valid runs runinfo(data, :p03)                             # all runs in period p03 runinfo(data, (:p03, :r005))                    # single-row Table for that run runinfo(data, (:p03, :r005, :phy))              # only the :phy entry runinfo(data, fk::FileKey)                      # same as above via FileKey\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.search_disk","page":"API","title":"LegendDataManagement.search_disk","text":"search_disk(::Type{<:DataSelector}, path::AbstractString)\nsearch_disk(::Type{DataSet}, data::LegendData; search_categories::Vector{<:DataCategoryLike} = DataCategory.([:cal, :phy]), search_tier::DataTierLike = DataTier(:raw), only_analysis_runs::Bool=true, save_filekeys::Bool=true, ignore_save_tier::Bool=false, save_tier::DataTierLike=DataTier(:jlfks))\n\nSearch on-disk data for data categories, periods, runs, and filekeys or whole datasets If you want to search for a whole DataSet, you have the following keyword options:     - search_categories (default: [:cal, :phy]): The categories to search on disk.     - search_tier (default: DataTier(:raw)): The tier to search on disk.     - only_analysis_runs (default: true): Only include for analysis runs as defined in the metadata     - save_filekeys (default: true): Save the filekeys to a file in the save_tier directory.     - ignore_save_tier (default: false): Ignore the save_tier and do not save the filekeys.     - save_tier (default: DataTier(:jlfks)): The tier to save the filekeys to.\n\nExamples:\n\nl200 = LegendData(:l200)\n\nsearch_disk(DataCategory, l200.tier[:raw])\nsearch_disk(DataPeriod, l200.tier[:raw, :cal])\nsearch_disk(DataRun, l200.tier[:raw, :cal, \"p02\"])\nsearch_disk(FileKey, l200.tier[DataTier(:raw), :cal, DataPeriod(2), \"r006\"])\nsearch_disk(DataSet, l200)\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.start_filekey","page":"API","title":"LegendDataManagement.start_filekey","text":"start_filekey(data::LegendData, runsel::RunCategorySelLike)\n\nGet the starting filekey for data in period, run, category.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.tmp_filename-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.tmp_filename","text":"LegendDataManagement.tmp_filename(fname::AbstractString)\n\nReturns a temporary filename, based on fname, in the same directory.\n\nDoes not create the temporary file.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.write_filekeys-Tuple{AbstractString, AbstractVector{<:FileKey}}","page":"API","title":"LegendDataManagement.write_filekeys","text":"write_filekeys(filename::AbstractString, filekeys::AbstractVector{<:FileKey})\n\nWrites a list of FileKey to a text file, one file key per line.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.writelprops","page":"API","title":"LegendDataManagement.writelprops","text":"writelprops(f::IO, p::PropDict; write_units::Bool=true, write_errors::Bool=true, mutliline::Bool=true, indent::Int=4)\nwritelprops(filename::AbstractString, p::PropDict; multiline::Bool=true, indent::Int=4)\nwritelprops(db::PropsDB, key::Union{Symbol, DataSelector}, p::PropDict; kwargs...)\n\nWrite a PropDict to a file and strip it to :val and :unit fields and :val and :err fields.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.writelreport","page":"API","title":"LegendDataManagement.writelreport","text":"writelreport(filename::AbstractString, rpt::LegendReport)\nwritelreport(filename::AbstractString, mime::MIME, rpt::LegendReport)\n\nWrite lreport rpt to file filename.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.channel2detector-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.channel2detector","text":"channel2detector(data::LegendData, sel::Union{AnyValiditySelection, RunCategorySelLike}, channel::ChannelIdLike)\n\nGet the DetectorId for a given ChannelId input: \n\ndata, e.g. LegendData(:l200)`\nrunsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\nchannel: ChannelId e.g. ChannelId(1080005)`\n\noutput:\n\nDetectorId of corresponding channel\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.create_logtbl-Tuple{Any}","page":"API","title":"LegendDataManagement.LDMUtils.create_logtbl","text":"create_logtbl(result)\n\nCreate a log table for a given result which can be added in a report.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.create_metadatatbl","page":"API","title":"LegendDataManagement.LDMUtils.create_metadatatbl","text":"create_metadatatbl(filekey::FileKey)\ncreate_metadatatbl(filekey::FileKey, part::DataPartitionLike)\n\nCreate a metadata table for a given filekey which can be added in a report.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.create_pars-Tuple{PropDicts.PropDict, Any}","page":"API","title":"LegendDataManagement.LDMUtils.create_pars","text":"create_pars(pd::PropDict, result::Dict{ChannelInfo, ChannelResult}) -> PropDict\n\nCreate a PropDict from a result of the parallel processing\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.create_validity-Tuple{Any}","page":"API","title":"LegendDataManagement.LDMUtils.create_validity","text":"create_validity(result) -> StructArray\n\nCreate a StructArray from a result of the parallel processing\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.data_starttime-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}}","page":"API","title":"LegendDataManagement.LDMUtils.data_starttime","text":"data_starttime(data::LegendData, runsel::Union{AnyValiditySelection, RunCategorySelLike})\n\nExtract startime as DateTime from file for a given run selection     Input:     * data: LegendData, e.g. LegendData(:l200)     * runsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.detector2channel-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, DetectorIdLike}","page":"API","title":"LegendDataManagement.LDMUtils.detector2channel","text":"detector2channel(data::LegendData, sel::Union{AnyValiditySelection, RunCategorySelLike}, detector::DetectorIdLike)\n\nGet the ChannelId for a given detectorId  input: \n\ndata, e.g. LegendData(:l200)`\nrunsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\ndetector: DetectorID e.g. DetectorId(:P00573A)OR ChannelID e.g.ChannelId(1080005)``\n\noutput:\n\nChannelId of corresponding detector\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.detector_type-Tuple{LegendData, DetectorIdLike}","page":"API","title":"LegendDataManagement.LDMUtils.detector_type","text":"get_det_type(data::LegendData, det::DetectorIdLike)\n\nLooks up the detector type for a given DetectorID.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_hitchfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.get_hitchfilename","text":"get_hitchfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_hitchfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the hitch data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_mltrainfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_mltrainfilename","text":"get_mltrainfilename(data::LegendData, period::DataPeriodLike, category::DataCategoryLike)\nget_mltrainfilename(data::LegendData, filekey::FileKey)\n\nGet the filename for the machine learning training data.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_partitionfilekeys-Tuple{LegendData, DataPartitionLike, DataTierLike}","page":"API","title":"LegendDataManagement.LDMUtils.get_partitionfilekeys","text":"get_partitionfilekeys(data::LegendData, part::DataPartitionLike, tier::DataTierLike, category::DataCategoryLike; only_good::Bool=true)\n\nGet filekeys for a given partition.\n\nArguments\n\ndata::LegendData: data object\npart::DataPartitionLike: partition to be searched in\ntier::DataTierLike: tier\ncategory::DataCategoryLike: category\nonly_good::Bool=true: only get good filekeys\n\nReturn\n\nVector{FileKey}: filekeys\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_partitionvalidity-Tuple{LegendData, DetectorIdLike, DataPartitionLike}","page":"API","title":"LegendDataManagement.LDMUtils.get_partitionvalidity","text":"get_partitionvalidity(data::LegendData, part::DataPartitionLike) -> Vector{@NamedTuple{period::DataPeriod, run::DataRun, validity::String}}\n\nGet partition validity for a given channel and partition.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_peaksfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.get_peaksfilename","text":"get_peaksfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_peaksfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the peaks data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_plottitle","page":"API","title":"LegendDataManagement.LDMUtils.get_plottitle","text":"get_plottitle(setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, det::DetectorIdLike, process::AbstractString; additional_type::AbstractString=\"\")\nget_plottitle(filekey::FileKey, det::DetectorIdLike, process::AbstractString; kwargs...)\nget_plottitle(setup::ExpSetupLike, partition::DataPartitionLike, category::DataCategoryLike, det::DetectorIdLike, process::AbstractString; additional_type::AbstractString=\"\")\nget_plottitle(filekey::FileKey, partition::DataPartitionLike, det::DetectorIdLike, process::AbstractString; kwargs...)\n\nGet the title for a plot.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_pltfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_pltfilename","text":"get_pltfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\n\nGet the filename for the plot file for a given setup, period, run, category, channel and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_pltfolder","page":"API","title":"LegendDataManagement.LDMUtils.get_pltfolder","text":"get_pltfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\nget_pltfolder(data::LegendData, filekey::FileKey, process::Symbol)\nget_pltfolder(data::LegendData, partition::DataPartitionLike, category::DataCategoryLike, process::Symbol, ch::ChannelIdOrDetectorIDLike)\n\nGet the folder for the plot files for a given period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_preportfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_preportfilename","text":"get_preportfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, category::DataCategoryLike, process::Symbol)\n\nGet the filename for the log file for a given setup, period, category and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_preportfolder","page":"API","title":"LegendDataManagement.LDMUtils.get_preportfolder","text":"get_preportfolder(data::LegendData, period::DataPeriodLike, category::DataCategoryLike)\n\nGet the preport folder for the log files for a given period and category.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_rreportfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_rreportfilename","text":"get_rreportfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\nget_rreportfilename(data::LegendData, filekey::FileKey, process::Symbol)\n\nGet the filename for the log file for a given setup, period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_rreportfolder","page":"API","title":"LegendDataManagement.LDMUtils.get_rreportfolder","text":"get_rreportfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike)\n\nGet the rreport folder for the log files for a given period, run and category.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_totalTimer-Tuple{Vector}","page":"API","title":"LegendDataManagement.LDMUtils.get_totalTimer","text":"get_totalTimer(result::Vector)\n\nGet the total timer from a result vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.load_partition_ch-Tuple{Function, Function, LegendData, TypedTables.Table, DataTierLike, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.load_partition_ch","text":"load_partition_ch(open_func::Function, flatten_func::Function, data::LegendData, partinfo::StructVector, tier::DataTierLike, cat::DataCategoryLike, ch::ChannelIdLike; data_keys::Tuple=(), n_evts::Int=-1, select_random::Bool=false)\nload_partition_ch(open_func::Function, flatten_func::Function, data::LegendData, part::DataPartition, tier::DataTierLike, cat::DataCategoryLike, ch::ChannelIdLike; kwargs...)\n\nLoad data for a channel from a partition. \n\nArguments\n\nopen_func::Function: function to open a file\nflatten_func::Function: function to flatten data\ndata::LegendData: data object\npartinfo::StructVector: partition info\ntier::DataTierLike: tier\ncat::DataCategoryLike: category\nch::ChannelIdLike: channel\ndata_keys::Tuple=(): data keys, empty tuple selects all keys\nn_evts::Int=-1: number of events, -1 selects all events\nselect_random::Bool=false: select events randomly\n\nReturn\n\nTable: data table with flattened events\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.load_raw_evt","page":"API","title":"LegendDataManagement.LDMUtils.load_raw_evt","text":"load_raw_evt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::Int)\nload_raw_evt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::UnitRange{Int})\n\nLoad data for a channel from a hitch file for a given selected event index or index range.\n\nArguments\n\nopen_func::Function: function to open a file\ndata::LegendData: data object\nch::ChannelIdLike: channel\ndata_hit::Table: hitch data\nsel_evt::Int/UnitRange{Int}: selected event index\n\nReturn\n\nTable: data table of raw events\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.load_run_ch","page":"API","title":"LegendDataManagement.LDMUtils.load_run_ch","text":"load_run_ch(open_func::Function, flatten_func::Function, data::LegendData, filekeys::Vector{FileKey}, tier::DataTierLike, ch::ChannelIdLike; check_filekeys::Bool=true)\n\nLoad data for a channel from a list of filekeys in a given tier.\n\nArguments\n\nopen_func::Function: function to open a file\nflatten_func::Function: function to flatten data\ndata::LegendData: data object\nfilekeys::Vector{FileKey}: list of filekeys\ntier::DataTierLike: tier to load data from\nch::ChannelIdLike: channel to load data for\ncheck_filekeys::Bool=true: check if filekeys are valid\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.savelfig","page":"API","title":"LegendDataManagement.LDMUtils.savelfig","text":"savelfig(save_func::Function, p, data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\n\nSave a lplot.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.writevalidity","page":"API","title":"LegendDataManagement.LDMUtils.writevalidity","text":"writevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey,\n              apply::Union{String,Vector{String}}; category::Symbol = :all, mode::String = \"reset\")\n\nwritevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey,\n              rsel::Tuple{DataPeriod,DataRun}; category::Symbol = :all)\n\nwritevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey,\n              part::DataPartitionLike; category::Symbol = :all)\n\nwritevalidity(props_db::LegendDataManagement.PropsDB,\n              validity_with_flag::NamedTuple{(:result, :skipped)}; category::Symbol = :all, impl::Symbol = :full)\n\nWrite validity information into validity.yaml.\n\nWith apply (string or vector), one or more validity files are written using the given mode (\"reset\", \"append\", \"remove\", or \"replace\").\nA (DataPeriod, DataRun) or DataPartition is automatically converted into the corresponding validity string.\nWith a NamedTuple(:result, :skipped), process a sequence of validity updates across detectors and partitions, using either the :full or :diff implementation.\n\nAll entries are merged chronologically into validity.yaml.\n\n\n\n\n\n","category":"function"},{"location":"Manual/data_access/#Data-access-and-discovery","page":"Data access and discovery","title":"Data access and discovery","text":"This tutorial demonstrates common workflows for discovering and reading LEGEND data using LegendDataManagement.jl. It assumes that a valid configuration file is available and referenced via the LEGEND_DATA_CONFIG environment variable.\n\n","category":"section"},{"location":"Manual/data_access/#Setup","page":"Data access and discovery","title":"Setup","text":"Ensure the configuration file is available to Julia:\n\nexport LEGEND_DATA_CONFIG=\"/path/to/legend_data_config.json\"\n\nLoad the required packages:\n\nusing LegendDataManagement\nusing LegendHDF5IO\n\n","category":"section"},{"location":"Manual/data_access/#Opening-a-dataset","page":"Data access and discovery","title":"Opening a dataset","text":"A dataset is opened by name as defined in the configuration file.\n\nl200 = LegendData(:l200)\n\nThe returned LegendData object serves as the main entry point for accessing data tiers and metadata.\n\n","category":"section"},{"location":"Manual/data_access/#Inspecting-available-data-tiers","page":"Data access and discovery","title":"Inspecting available data tiers","text":"with the search_disk function you can check what kind of data is available to you in the LegendData object:\n\nYou can check for available DataTier with\n\nsearch_disk(DataTier, l200.tier[])\n\nand available DataCategory with\n\nsearch_disk(DataCategory, l200.tier[:raw])\n\n","category":"section"},{"location":"Manual/data_access/#Data-selectors","page":"Data access and discovery","title":"Data selectors","text":"Data selection is performed using data selectors rather than hard-coded paths. Common selectors include:\n\nDataCategory(:XXX)\nDataPeriod(pXX)\nDataRun(rXXX)\nDetectorID(XYYYYYZ)","category":"section"},{"location":"Manual/data_access/#Reading-data","page":"Data access and discovery","title":"Reading data","text":"Data can be loaded using read_ldata. First, specify the LegendData object and DataTier, then provide a set of selectors to restrict the data to the subset you want to read.\n\ndata = read_ldata(l200, :jlhit, DataCategory(:cal), DataPeriod(p03), DataRun(r001), DetectorID(:V08682A))\n\nMore about the readldata function can be found in Manual/readldata","category":"section"},{"location":"Manual/read_ldata/","page":"-","title":"-","text":"File explaining of to use the read_ldata function","category":"section"},{"location":"Manual/validity/#Validity-and-metadata","page":"Validity & metadata","title":"Validity & metadata","text":"LEGEND uses a validity-based metadata model to describe which files are active for a given category and time. This tutorial explains the structure of validity entries and how to apply them in practice.\n\n","category":"section"},{"location":"Manual/validity/#Validity-entry-structure","page":"Validity & metadata","title":"Validity entry structure","text":"Each validity entry contains the following fields:\n\nvalid_from: timestamp indicating when the change becomes effective.\ncategory: metadata category, e.g., \"cal\", \"phy\", \"all\". Here \"all\" means NOT does apply to all cetegories, but is its own category. \nmode: operation type, one of reset, append, remove, or replace.\napply: list of files affected by the operation.\n\nExample:\n\n- valid_from: \"20221118T000000Z\"\n  category: \"cal\"\n  mode: \"append\"\n  apply:\n    - /data/l200/partition1/cal/fileA.h5\n    - /data/l200/partition1/cal/fileB.h5\n\n","category":"section"},{"location":"Manual/validity/#Modes","page":"Validity & metadata","title":"Modes","text":"reset: replaces the entire active file list with the entries in apply.\nappend: adds the listed files to the current active list.\nremove: deletes the listed files from the current active list.\nreplace: substitutes one file for another.\n\n","category":"section"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"section"},{"location":"#LegendDataManagement.jl","page":"Home","title":"LegendDataManagement.jl","text":"LegendDataManagement.jl provides a Julia implementation of the LEGEND data and metadata management.\n\nThe package provides a structured interface to locate, access, and query LEGEND data across data tiers, periods, runs, and channels, and integrates with the LEGEND metadata.","category":"section"},{"location":"#Configuration","page":"Home","title":"Configuration","text":"The package expects a configuration file (see the example \"config.yaml\" in the LEGEND test data repository) describing dataset names, file roots, and partitions. While the path to this configuration file can be specified explicitly, we recommend setting an environment variable named $LEGEND_DATA_CONFIG to the absolute path of your \"config.json\". This can be done in the bashrc or for VisualStudioCode in terminal.integrated.env.linux\".\n\nexport LEGEND_DATA_CONFIG=\"/path/to/legend_data_config.json\"\n\nLegendDataManagment provides a SolidStateDetectors extension that makes it possible to create SolidStateDetector objects from LEGEND metadata.\n\nUsage examples:\n\nusing LegendDataManagement\nusing PropertyFunctions\n\nl200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nraw_filename = l200.tier[:raw, \"l200-p02-r006-cal-20221226T200846Z\"]\n\nl200.metadata.hardware.detectors.germanium.diodes\n\nchinfo = channel_info(l200, filekey)\nfilterby(@pf $processable && $usability)(chinfo)","category":"section"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"Examples provide step-by-step workflows for common data access and metadata-management tasks.\nAPI contains the automatically generated reference documentation for exported types and functions.\n\n","category":"section"},{"location":"#Get-started","page":"Home","title":"Get started","text":"Browse the Manual for a explanation of basic functions and practical examples.\nCheck the Tutorials section for ...\nCheck Extenstions for an explantion about the Package extensions of Plots, LegendHDF5IO and SolidStateDetectors.\nConsult the API section for detailed information on selectors and helper functions such as LegendData, DataTier, DataPeriod, search_disk, and read_ldata.","category":"section"},{"location":"extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"extensions/#Plots-extension","page":"Extensions","title":"Plots extension","text":"LegendDataManagment provides an extension for Plots. This makes it possible to directly plot LEGEND data via the plot function. The extension is automatically loaded when both packages are loaded. You can plot a parameter overview as a 2D plot over a set of detectors (requires a $LEGEND_DATA_CONFIG environment variable pointing to a legend data-config file):\n\nusing LegendDataManagement, Plots\n\nl200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p03-r000-cal-20230311T235840Z\")\n\npars = l200.par.ppars.ecal(filekey)\nproperties = [:e_cusp_ctc, :fwhm, :qbb];\n\nchinfo = channelinfo(l200, filekey; system = :geds, only_processable = true)\n\nplot(chinfo, pars, properties, verbose = true, color = 1, markershape = :o, calculate_mean = true)\n\nThe plot recipe takes three arguments:\n\nchinfo: the channel info with all detectors to be plotted on the x-axis\npars: a PropDict that has the detector IDs as keys and parameters as values\nproperties: an array of Symbols to access the data that should be plotted\n\n(if no properties are provided, the PropDict pars is expected to just contain the data to be plotted as values)\n\nThere are also keyword arguments:\n\ncalculate_mean: If set to true, then the mean values are included in the legend labels. For values with uncertainties, the mean values are calculated as weighted means.\nverbose: some output when the plot is generated, e.g. if values for (some) detectors are missing\n\nA 3D plot is WIP.\n\nIn addition, you can plot an event display of the raw waveforms:\n\nusing Unitful, LegendDataManagement, Plots\n\nl200 = LegendData(:l200)\n\nts = 1.6785791257987175e9u\"s\"\n\nch = ChannelId(1104000)\n\nplot(l200, ts, ch)\n\nplot_tier: The data tier to be plotted. Default is DataTier(:raw).\nplot_waveform: All waveforms to be plotted from the data. Default is [:waveform_presummed] which plots the presummed waveform.\nshow_unixtime: If set to true, use unix time instead of the datetime in the title. Default is false.\n\nIf the channel is not given, the recipe automtically searches for the correct event in the data.\n\nts = 1.6785791257987175e9u\"s\"\n\nplot(l200, ts)\n\nIn case of a cal event, only the HPGe channel with that event is plotted. In case of a phy event, all waveforms of the full HPGe and SiPM systems are plotted.  The following additional keywords arguments can be set (the plot_waveform kwarg is replaced by the system kwarg here):\n\nsystem: The system and the waveforms to be plotted for each system. Default is Dict{Symbol, Vector{Symbol}}([:geds, :spms] .=> [[:waveform_presummed], [:waveform_bit_drop]])\nonly_processable: If set to true, only processable channels are plotted. Default is true.","category":"section"},{"location":"extensions/#LegendHDF5IO-extension","page":"Extensions","title":"LegendHDF5IO extension","text":"LegendDataManagment provides an extension for LegendHDF5IO. This makes it possible to directly load LEGEND data from HDF5 files via the read_ldata function. The extension is automatically loaded when both packages are loaded.  Example (requires a $LEGEND_DATA_CONFIG environment variable pointing to a legend data-config file):\n\nusing LegendDataManagement, LegendHDF5IO\nl200 = LegendData(:l200)\nfilekeys = search_disk(FileKey, l200.tier[:jldsp, :cal, :p03, :r000])\n\nchinfo = channelinfo(l200, (:p03, :r000, :cal); system=:geds, only_processable=true)\n\nch = chinfo[1].channel\n\ndsp = read_ldata(l200, :jldsp, first(filekeys), ch)\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, ch)\ndsp = read_ldata((:e_cusp, :e_trap, :blmean, :blslope), l200, :jldsp, :cal, :p03, :r000, ch)\n\nread_ldata automitcally loads LEGEND data for a specific DataTier and data selection like e.g. a FileKey or a run-selection based for a given ChannelId. The search_disk function allows the user to search for available DataTier and FileKey on disk. The first argument can be either a selection of keys in form of a NTuple of Symbol or a PropertyFunction which will be applied during loading.  It is also possible to load whole a DataPartition or DataPeriod for a given ChannelId ch:\n\ndsp = read_ldata(l200, :jldsp, :cal, DataPartition(1), ch)\ndsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch)\n\nIn additon, it is possible to load a random selection of n_evts events randomly selected from each loaded file:\n\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, ch; n_evts=1000)\n\nFor simplicity, the ch can also be given as a DetectorID which will be converted internally to a ChannelId:\n\ndet = chinfo[1].detector\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, det)\n\nIn case, a ChannelId is missing in a file, the function will throw an ArgumentError. To avoid this and return nothing instead, you can use the ignore_missing keyword argument.\n\nThe data can be filtered by a filterby keyword argument which is a PropertyFunction applied to each chunk of loaded data:\n\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, ch; filterby=@pf($e_trap > 0.0))\n\nThis will only load data where the e_trap property is greater than 0.\n\nIt is possible to read in multiple files in parallel using the Distributed functionalities from within a session. You can activate parallel read with the parallel kwarg.\n\ndsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch)\ndsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch; parallel=true)\n\nHowever, it is necessary that a worker allocation was already performed and the LegendDataManagement as well as LegendHDF5IO package is loaded on all workers, e.g. with\n\nusing Distributed\naddprocs(4)\n@everywhere using LegendDataManagement, LegendHDF5IO\n\nIn addition, the wpoolkwarg allows to parse a custome WorkerPool for more sophisticated load patterns.","category":"section"},{"location":"extensions/#SolidStateDetectors-extension","page":"Extensions","title":"SolidStateDetectors extension","text":"LegendDataManagment provides an extension for SolidStateDetectors. This makes it possible to create SolidStateDetector and Simulation instances from LEGEND metadata. The default drift model used when creating a detector/simulation through LegendDataManagment is ADLChargeDriftModel2016.\n\nExample (requires a $LEGEND_DATA_CONFIG environment variable pointing to a legend data-config file):\n\nusing LegendDataManagement, SolidStateDetectors, Plots\ndet = SolidStateDetector(LegendData(:l200), :V99000A)\nplot(det)\n\nst = :slice keyword can be passed to the plot to plot a 2D slice of the detector. Using the previous constructor looks up the diode and crystal metadata files. This can also be done manually with the following constructor  which can also be used directly (no $LEGEND_DATA_CONFIG required):\n\ndet = SolidStateDetector(LegendData, \"V99000A.yaml\", \"V99000.yaml\")\n\nIn cases where multiple values (or none) are available in the metadata, the detector is configured using the following priority:\n\nn contact thickness: 0 analysis value (if available)  manufacturer's value (if available)  default value. Can also be overridden with n_thickness keyword.\nOperational Voltage: l200 characterization value (if available)  manufacturer's value (if available)  default value. Can also be overridden with operational_voltage keyword.\nImpurity profile: model in crystal metadata (if available)  constant value of 0\n\nTo create a SolidStateDetectors Simulation or SolidStateDetector LegendDataManagement creates a SolidStateDetectors config. Although this process is entirely internal, and does not require any files to be written to disk, the user can choose to do so by using the ssd_config_filename keyword (e.g. ssd_config_filename = \"../V99000A_ssd_config.yaml\"). If set, a YAML file will be written as specified. This file which can then be modified and used by SolidStateDetectors independently of LegendDataManagement (e.g. Simulation{T}(\"../V99000A_ssd_config.yaml\")). By default ssd_config_filename is set to missing. \n\nnote: Note\nSimulating a LEGEND detector from a modified ssd_config can lead to errors and divergent behavior from LEGEND defaults. Please read the SolidStateDetectors documentation before proceeding.\n\nIn addition, when creating a Simulation, all simulation functions in SolidStateDetectors.jl can be applied. As usual, all fields stored in the Simulation can be written and read using LegendHDF5IO:\n\nusing LegendDataManagement\nusing SolidStateDetectors\nusing Unitful\n\nT=Float32\n\nsim = Simulation{T}(LegendData(:l200), :V99000A, HPGeEnvironment(\"LAr\", 87u\"K\"), n_thickness = 0.7u\"mm\", operational_voltage = 4u\"kV\")\nsimulate!(sim) # calculate electric field and weighting potentials\n\nusing LegendHDF5IO\nssd_write(\"V99000A.lh5\", sim)\nsim_in = ssd_read(\"V99000A.lh5\", Simulation)\n\nThe following code will generate an overview plot of every 5th LEGEND detector (requires the actual LEGEND metadata instead of the metadata in legend-testdata):\n\nusing LegendDataManagement, SolidStateDetectors, Plots\nl200 = LegendData(:l200)\ndetnames = propertynames(l200.metadata.hardware.detectors.germanium.diodes)\nplot(\n    plot.(SolidStateDetector.(Ref(l200), detnames[1:5:120]))...,\n    layout = (3,8), lw = 0.05, legend = false, grid = false, showaxis = false,\n    xlims = (-0.05,0.05), ylims = (-0.05,0.05), zlims = (0,0.1), size = (4000,1500)\n)","category":"section"}]
}
