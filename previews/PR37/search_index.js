var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LegendDataManagement]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#LegendDataManagement.AbstractSetupData","page":"API","title":"LegendDataManagement.AbstractSetupData","text":"abstract type AbstractSetupData\n\nSubtypes wrap SetupConfig for specific experiments.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ChannelId","page":"API","title":"LegendDataManagement.ChannelId","text":"struct ChannelId <: DataSelector\n\nRepresents a LEGEND data channel.\n\nExample:\n\nch = ChannelId(1083204)\n# ch = ChannelId(98) # with old channel numbering\nch.no == 1083204\nstring(ch) == \"ch1083204\"\nChannelId(\"ch1083204\") == ch\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataCategory","page":"API","title":"LegendDataManagement.DataCategory","text":"struct DataCategory <: DataSelector\n\nRepresents a LEGEND data category (related to a DAQ/measuring mode) like \"cal\" or \"phy\".\n\nExample:\n\ncategory = DataCategory(:cal)\ncategory.label == :cal\nstring(category) == \"cal\"\nDataCategory(\"cal\") == category\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPartition","page":"API","title":"LegendDataManagement.DataPartition","text":"struct DataPartition <: DataSelector\n\nRepresents a LEGEND data-taking partition.\n\nExample:\n\npartition = DataPartition(1)\npartition.no == 1\nstring(partition) == \"partition01\"\nDataPartition(\"partiton01\") == partition\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPeriod","page":"API","title":"LegendDataManagement.DataPeriod","text":"struct DataPeriod <: DataSelector\n\nRepresents a LEGEND data-taking period.\n\nExample:\n\nperiod = DataPeriod(2)\nperiod.no == 2\nstring(period) == \"p02\"\nDataPeriod(\"p02\") == period\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataRun","page":"API","title":"LegendDataManagement.DataRun","text":"struct DataRun <: DataSelector\n\nRepresents a LEGEND data-taking run.\n\nExample:\n\nr = DataRun(6)\nr.no == 6\nstring(r) == \"r006\"\nDataRun(\"r006\") == r\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataSelector","page":"API","title":"LegendDataManagement.DataSelector","text":"abstract type DataSelector\n\nAbstract type for data selectors like ExpSetup, DataTier, DataPeriod, DataRun, DataCategory, Timestamp and FileKey.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataTier","page":"API","title":"LegendDataManagement.DataTier","text":"struct DataTier <: DataSelector\n\nRepresents a LEGEND data tier like \"raw, \"dsp\", etc.\n\nExample:\n\ntier = DataTier(:raw)\ntier.label == :raw\nstring(tier) == \"raw\"\nDataTier(\"raw\") == tier\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DetectorId","page":"API","title":"LegendDataManagement.DetectorId","text":"struct DetectorId <: DataSelector\n\nRepresents a LEGEND detector id id.\n\nExample:\n\ndetector = DetectorId(:V99000A)\ndetector.label == :V99000A\nstring(detector) == \"V99000A\"\nDetectorId(\"V99000A\") == detector\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ExpSetup","page":"API","title":"LegendDataManagement.ExpSetup","text":"struct ExpSetup <: DataSelector\n\nRepresents a LEGEND experimental setup like \"l200\".\n\nExample:\n\nsetup = ExpSetup(:l200)\nsetup.label == :l200\nstring(setup) == \"l200\"\nExpSetup(\"l200\") == setup\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.FileKey","page":"API","title":"LegendDataManagement.FileKey","text":"struct FileKey <: DataSelector\n\nRepresents a LEGEND file key.\n\nExample:\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nSee also read_filekeys and write_filekeys.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendData","page":"API","title":"LegendDataManagement.LegendData","text":"struct LegendData <: AbstractSetupData\n\nProvides access to LEGEND data and metadata.\n\nConstructors:\n\nLegendData(setup_config::SetupConfig).\nLegendData(setup::Symbol) - requires the $LEGEND_DATA_CONFIG environment variable to be set.\n\nExamples:\n\nconfig_filename = \"/path/to/config.json\"\nconfig = LegendDataConfig(config_filename)\nl200 = LegendData(config.setups.l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nor simply (if $LEGEND_DATA_CONFIG is set):\n\nl200 = LegendData(:l200)\n\nLegendData has the (virtual) properties metadata and tier.\n\nThe full path to \"tier\" data files can be retrieved using\n\n(data::LegendData)[tier::Symbol, filekey::FileKey]\n(data::LegendData).tier[tier::Symbol, filekey::AbstractString]\n\nExample:\n\nl200.tier[:raw]\nl200.tier[:raw, FileKey(\"l200-p02-r006-cal-20221226T200846Z\")]\n\nLegendData comes with an extension for SolidStateDetectors:\n\nl200 = LegendData(:l200)\nSolidStateDetector(l200, :V99000A)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendDataConfig","page":"API","title":"LegendDataManagement.LegendDataConfig","text":"struct LegendDataConfig\n\nData configuration multiple experimental setups.\n\nContains a single field setups::PropertyDict{Symbol,SetupConfig}.\n\nCan be read from a config file via LegendDataConfig(config_filename[s]), or simply LegendDataConfig() if the environment variable $LEGEND_DATA_CONFIG is set. $LEGEND_DATA_CONFIG may be a list of colon-separated config filenames, which are applied/merged in reverse order (analog to the order of prioritiy in $PATH and similar).\n\nExample:\n\nconfig = LegendDataConfig(\"/path/to/config.json\")\nsetup = config.setups.l200\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\nSee also SetupConfig.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendReport","page":"API","title":"LegendDataManagement.LegendReport","text":"struct LegendReport\n\nRepresents a LEGEND report.\n\nDon't instantiate directly, use lreport()\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendTierData","page":"API","title":"LegendDataManagement.LegendTierData","text":"struct LegendDataManagement.LegendTierData\n\nConstructors:\n\n(data::LegendData).tier\n\nLegendDataManagement.LegendTierData(data::LegendData)\n\nThe path to data directories and files can be accessed via getindex on tier_data::LegendTierData:\n\ntier_data[]\ntier_data[tier::DataTierLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike]\n\ntier_data[tier::DataTierLike, filekey::FileKeyLike]\n\nExamples:\n\n```julia l200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\") isfile(l200.tier[:raw, filekey])\n\nisdir(l200.tier[:raw, :cal]) isdir(l200.tier[:raw, :cal, \"p02\"]) isdir(l200.tier[:raw, :cal, \"p02\", \"r006\"]) isdir(l200.tier[DataTier(:raw), DataCategory(:cal), DataPeriod(2), DataRun(6)])\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.NoSuchPropsDBEntry","page":"API","title":"LegendDataManagement.NoSuchPropsDBEntry","text":"struct LegendDataManagement.NoSuchPropsDBEntry\n\nIndicates that a given property (path) of a LegendDataManagementPropsDB[@ref] does not exist.\n\nSupports PropDicts.writeprops(missing_props::NoSuchPropsDBEntry, props::PropDicts.PropDict) to create the missing directories and file for the property path.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ProcessStatus","page":"API","title":"LegendDataManagement.ProcessStatus","text":"@enum ProcessStatus\n\nMay be succeeded, pending, or failed.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.PropsDB","page":"API","title":"LegendDataManagement.PropsDB","text":"struct LegendDataManagement.PropsDB\n\nA PropsDB instance, e.g. myprops, presents an on-disk directory containing JSON files or sub-directories (that contains JSON files in leaf directories) as a dictionary of properties.\n\nPropsDB supports Base.keys and Base.getindex as well as Base.propertynames and Base.getproperty to access it's contents. getindex and getproperty will return either another PropsDB or a PropDicts.PropDict, depending on whether the accessed property is stored as a sub-directory or a JSON file. We recommend to use getproperty where the properties/keys of the PropDict are more or less standardized and where they may be arbitrary (see examples below).\n\nThe contents of PropsDB may be time- and category-dependent, determined by the presence of a \"validity.json\" file. In this case, use myprops(sel::LegendDataManagement.ValiditySelection) or myprops(filekey::FileKey) to select the desired time and category. The selection can be made at some point during traversal of properties or at the leaf PropsDB (see the examples below).\n\nExamples:\n\nl200 = LegendData(:l200)\n\npropertynames(l200.metadata.hardware)\nl200.metadata.hardware.detectors.germanium\n\nkeys(l200.metadata.hardware.detectors.germanium.diodes)\nl200.metadata.hardware.detectors.germanium.diodes[:V99000A]\n\ndiodes = l200.metadata.hardware.detectors.germanium.diodes\ndiodes[keys(diodes)]\n\nsel = ValiditySelection(\"20221226T194007Z\", :cal)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T194007Z\")\ndata.metadata.hardware(sel).configuration.channelmaps\ndata.metadata.hardware.configuration.channelmaps(filekey)\n\nUse code should not instantiate PropsDB directly, use  LegendDataManagement.AnyProps(path::AbstractString) instead, which may return a PropsDB or a PropDicts.PropDict depending on what on-disk content path points to. \n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.RunCategorySelLike","page":"API","title":"LegendDataManagement.RunCategorySelLike","text":"struct RunCategorySelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.RunSelLike","page":"API","title":"LegendDataManagement.RunSelLike","text":"struct RunSelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.SetupConfig","page":"API","title":"LegendDataManagement.SetupConfig","text":"struct SetupConfig\n\nData configuration for an experimental setup.\n\nSupports\n\ndata_path(setup, path_components)\n\nExamples:\n\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.Timestamp","page":"API","title":"LegendDataManagement.Timestamp","text":"struct Timestamp <: DataSelector\n\nRepresents a LEGEND timestamp.\n\nExample:\n\njulia timestamp = Timestamp(\"20221226T200846Z\") timestamp.unixtime == 1672085326 string(timestamp) == \"20221226T200846Z\"`\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ValiditySelection","page":"API","title":"LegendDataManagement.ValiditySelection","text":"struct LegendDataManagement.ValiditySelection\n\nRepresenty validiy selection for a LegendDataManagement.PropsDB[@ref].\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.AnyProps","page":"API","title":"LegendDataManagement.AnyProps","text":"LegendDataManagement.AnyProps = Union{LegendDataManagement.PropsDB,PropDicts.PropDict}\n\nProperties stored either in a directory managed via [LegendDataManagement.PropsDB][@ref] or loaded from one or several files into a PropDicts.PropDict.\n\nConstructors:\n\nLegendDataManagement.AnyProps(base_path::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.AnyValiditySelection","page":"API","title":"LegendDataManagement.AnyValiditySelection","text":"const AnyValiditySelection = Union{ValiditySelection,FileKey}\n\nAnything that can be used in time/category-based data selection.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ChannelIdLike","page":"API","title":"LegendDataManagement.ChannelIdLike","text":"ChannelIdLike = Union{ChannelId, Integer, AbstractString}\n\nAnything that can represent a data channel, like ChannelId(1083204) or \"ch1083204\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataCategoryLike","page":"API","title":"LegendDataManagement.DataCategoryLike","text":"DataCategoryLike = Union{DataCategory, Symbol, AbstractString}\n\nAnything that can represent a data category, like DataCategory(:cal), :cal or \"cal\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPartitionLike","page":"API","title":"LegendDataManagement.DataPartitionLike","text":"DataPartitionLike = Union{DataPartition, Symbol, AbstractString}\n\nAnything that can represent a data partition, like DataPartition(2) or \"partition02\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPeriodLike","page":"API","title":"LegendDataManagement.DataPeriodLike","text":"DataPeriodLike = Union{DataPeriod, Symbol, AbstractString}\n\nAnything that can represent a data period, like DataPeriod(2) or \"p02\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataRunLike","page":"API","title":"LegendDataManagement.DataRunLike","text":"DataRunLike = Union{DataRun, Symbol, AbstractString}\n\nAnything that can represent a data run, like DataRun(6) or \"r006\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataTierLike","page":"API","title":"LegendDataManagement.DataTierLike","text":"DataTierLike = Union{DataTier, Symbol, AbstractString}\n\nAnything that can represent a data tier, like DataTier(:raw), :raw or \"raw\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DetectorIdLike","page":"API","title":"LegendDataManagement.DetectorIdLike","text":"DetectorIdLike = Union{DetectorId, Symbol, AbstractString}\n\nAnything that can represent a detector id.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ExpSetupLike","page":"API","title":"LegendDataManagement.ExpSetupLike","text":"ExpSetupLike = Union{ExpSetup, Symbol, AbstractString}\n\nAnything that can represent a setup label, like ExpSetup(:l200), :l200 or \"l200\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.FileKeyLike","page":"API","title":"LegendDataManagement.FileKeyLike","text":"FileKeyLike = Union{FileKey, AbstractString}\n\nAnything that can represent a file key, like FileKey(\"l200-p02-r006-cal-20221226T200846Z\") or \"l200-p02-r006-cal-20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LJlExprLike","page":"API","title":"LegendDataManagement.LJlExprLike","text":"const LJlExprLike = Union{Expr, Symbol, Integer, AbstractFloat}\n\nAnything that can represent a parsed LEGEND Julia expression.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.TimestampLike","page":"API","title":"LegendDataManagement.TimestampLike","text":"TimestampLike = Union{Timestamp, AbstractString, Integer}\n\nAnything that can represent a timestamp, like Timestamp(\"20221226T200846Z\") or \"20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.analysis_runs-Tuple{LegendData}","page":"API","title":"LegendDataManagement.analysis_runs","text":"analysis_runs(data::LegendData)\n\nReturn cross-period analysis runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.atomic_fcreate-Tuple{Any, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.atomic_fcreate","text":"function atomic_fcreate(\n    body, filenames::AbstractString...;\n    create_dirs::Bool = true, overwrite::Bool = true, delete_on_error::Bool=true\n)\n\nCreates filenames in an atomic fashion.\n\nCreates temporary files in the same directories as filenames, then calls body(temporary_filenames...). If body returns successfully, the files temporary_filenames are renamed to filenames. If body throws an exception, the temporary files are either deleted (if delete_on_error is true) or left in place (e.g. for debugging purposes).\n\nIf create_dirs is true, directories are created if necessary.\n\nIf all of files already exist and overwrite is false, takes no action (or, if the file is created by other code running in parallel, while body is running, does not overwrite it).\n\nThrows an error if only some of the files exist and overwrite is false.\n\nReturns nothing.\n\nExample:\n\natomic_fcreate(\"foo.txt\", \"bar.txt\") do foo, bar\n    write(foo, \"Hello\")\n    write(bar, \"World\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.bad_filekeys-Tuple{LegendData}","page":"API","title":"LegendDataManagement.bad_filekeys","text":"bad_filekeys(data::LegendData)\n\nGet the list of filekeys to ignore for data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.channelinfo-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection; system::Symbol = :all, only_processable::Bool = false)\nchannelinfo(data::LegendData, sel::RunCategorySelLike; system::Symbol = :all, only_processable::Bool = false)\n\nGet all channel information for the given LegendData and ValiditySelection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.channelinfo-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, Union{ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection, channel::ChannelIdLike)\nchannelinfo(data::LegendData, sel::AnyValiditySelection, detector::DetectorIdLike)\n\nGet channel information validitiy selection and DetectorId resp. ChannelId.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path","page":"API","title":"LegendDataManagement.data_path","text":"data_path(setup::SetupConfig, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\nConverts between \"/\" and \"\\\" inside of path_components if necessary (for Windows compatibility).\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.AbstractSetupData, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(setup::AbstractSetupData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.LegendTierData, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(tier_data::LegendTierData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components relative to tier_data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.PropsDB}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(pd::LegendDataManagement.PropsDB)\n\nReturn the path to the data directory that contains pd.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_config-Tuple{LegendData}","page":"API","title":"LegendDataManagement.dataprod_config","text":"dataprod_config(data::LegendData)\n\nGet the Julia data production configuration for data.\n\nUse dataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\ndataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\ndataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_parameters-Tuple{LegendData}","page":"API","title":"LegendDataManagement.dataprod_parameters","text":"dataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_pars_aoe_window-Tuple{LegendData, ValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.dataprod_pars_aoe_window","text":"LegendDataManagement.dataprod_pars_aoe_window(data::LegendData, sel::ValiditySelection, detector::DetectorId)\n\nGet the A/E cut window for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_cal_propfunc-Tuple{LegendData, ValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_cal_propfunc","text":"get_ged_cal_propfunc(data::LegendData, sel::ValiditySelection, detector::DetectorId)\n\nGet the HPGe calibration function for the given data, validity selection and detector.\n\nReturns a PropertyFunction that takes a table-like data object with columns e_trap, e_cusp, e_zac and qdrift and returns a StructArrays with columns e_trap_cal, e_cusp_cal, e_zac_cal, e_trap_ctc_cal, e_cusp_ctc_cal and e_zac_ctc_cal.\n\nNote: Caches configuration/calibration data internally, use a fresh data object if on-disk configuration/calibration data may have changed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_cuts_propfunc-Tuple{LegendData, ValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_qc_cuts_propfunc","text":"LegendDataManagement.get_ged_qc_cuts_propfunc(data::LegendData, sel::ValiditySelection)\n\nHardcoded Ge-detector quality cuts.\n\nNote: Temporary workaround for world-age problems with ljl_propfunc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_isgood_propfunc-Tuple{LegendData, ValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_qc_isgood_propfunc","text":"get_ged_qc_isgood_propfunc(data::LegendData, sel::ValiditySelection)\n\nGet a PropertyFunction that returns true for events that pass the Ge-detector quality cuts.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pulser_cal_propfunc-Tuple{LegendData, ValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_pulser_cal_propfunc","text":"get_pulser_cal_propfunc(data::LegendData, sel::ValiditySelection, detector::DetectorId)\n\nGet the pulser calibration function for the given data, validity selection and the pulser channel referred to by detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_setup_config","page":"API","title":"LegendDataManagement.get_setup_config","text":"LegendDataManagement.get_setup_config(data::AbstractSetupData)::SetupConfig\n\nMust be specialized for each subtype of AbstractSetupData.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_spm_cal_propfunc-Tuple{LegendData, ValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_spm_cal_propfunc","text":"get_spm_cal_propfunc(data::LegendData, sel::ValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_uncertainties","page":"API","title":"LegendDataManagement.get_uncertainties","text":"get_uncertainties(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_uncertainties(x::Unitful.Quantity{<:Real})\nget_uncertainties(pd::PropDict)\nget_uncertainties(A::AbstractArray)\n\nGet the uncertainty of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_values","page":"API","title":"LegendDataManagement.get_values","text":"get_values(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_values(x::Unitful.Quantity{<:Real})\nget_values(pd::PropDict)\nget_values(A::AbstractArray)\n\nGet the value of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.is_analysis_run-Tuple{LegendData, DataPeriodLike, Union{DataRun, AbstractString, Symbol}}","page":"API","title":"LegendDataManagement.is_analysis_run","text":"is_analysis_run(data::LegendData, period::DataPeriod, run::DataRun)\n\nReturn true if run is an analysis run for data in period.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.legend_addprocs","page":"API","title":"LegendDataManagement.legend_addprocs","text":"legend_addprocs(nprocs::Integer)\n\nAdd Julia workers for LEGEND data processing.\n\nCalls Distributed.addprocs with some specific options.\n\nEnsures that all workers processes use the same Julia project environment as the current process. Requires that file systems paths are consistenst across compute nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.livetime-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"API","title":"LegendDataManagement.livetime","text":"phy_livetime(data::LegendData, runsel::RunSelLike)\n\nGet the livetime for data in physics data taking of run in period.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.ljl_propfunc","page":"API","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr::LJlExprLike)\nljl_propfunc(expr_string::AbstractString)\n\nCompiles a PropertyFunctions.PropertyFunction from a LEGEND Julia expression.\n\nSee also parse_lpyexpr.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.ljl_propfunc-Tuple{AbstractDict{Symbol, <:Union{AbstractFloat, Expr, Integer, Symbol}}}","page":"API","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr_map::AbstractDict{Symbol,<:LJlExprLike})\nljl_propfunc(expr_map::AbstractDict{Symbol,<:AbstractString})\nljl_propfunc(expr_map::PropDict)\n\nCompiles a map between output field-names and LEGEND Julia expressions to a single PropertyFunctions.PropertyFunction.\n\nThe generated function will return NamedTuples with the same property names as the keys of expr_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.lpy_propfunc-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.lpy_propfunc","text":"lpy_propfunc(expr_string::AbstractString)::PropertyFunctions.PropertyFunction\n\nGenerate a PropertyFunctions.PropertyFunction from a LEGEND Python expression.\n\nSee also parse_lpyexpr and ljl_propfunc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.lreport","page":"API","title":"LegendDataManagement.lreport","text":"lreport()\nlreport(contents...)\n\nGenerate a LEGEND report, e.g. a data processing report.\n\nUse lreport!(rpt, contents...) to add more content to a report.\n\nExample:\n\nusing LegendDataManagement, StructArrays, IntervalSets, Plots\n\ntbl = StructArray(\n    col1 = rand(5), col2 = ClosedInterval.(rand(5), rand(5).+1),\n    col3 = [rand(3) for i in 1:5], col4 = ProcessStatus.(rand(-1:1, 5)),\n    col5 = [:a, :b, :c, :d, :e], col6 = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    col7 = [:(a[1]), :(a[2]), :(a[3]), :(a[4]), :(a[5])]\n)\n\nrpt = lreport(\n    \"# New report\",\n    \"Table 1:\", tbl\n)\nlreport!(rpt, \"Figure 1:\", stephist(randn(10^3)))\nlreport!(rpt, \"Figure 2:\", histogram2d(randn(10^4), randn(10^4), format = :png))\n\nshow(stdout, MIME\"text/plain\"(), rpt)\nshow(stdout, MIME\"text/html\"(), rpt)\nshow(stdout, MIME\"text/markdown\"(), rpt)\n\nwritelreport(\"report.txt\", rpt)\nwritelreport(\"report.html\", rpt)\nwritelreport(\"report.md\", rpt)\n\nSee LegendDataManagement.lreport_for_show! for how to specialize the behavior of show for specific report content types.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.lreport!","page":"API","title":"LegendDataManagement.lreport!","text":"lreport!(rpt::LegendReport, contents...)\n\nAdd more content to report rpt. See lreport for an example.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.lreport_for_show!","page":"API","title":"LegendDataManagement.lreport_for_show!","text":"LegendDataManagement.lreport_for_show!(rpt::LegendReport, mime::MIME, content)\n\nAdd the contents of content to rpt in a way that is optimized for being displayed (e.g. via show) with the given mime type.\n\nshow(output, mime, rpt) first transforms rpt by converting all contents of rpt using lreport_for_show!(rpt::LegendReport, mime, content).\n\nDefaults to lreport!(rpt, content), except for tables (Tables.istable(content) == true), which are converted to Markdown tables by default for uniform appearance.\n\nlreport_for_show! is not inteded to be called by users, but to be specialized for specific types of content content. Content types not already supported will primarily require specialization of\n\nlreport_for_show!(rpt::LegendReport, ::MIME\"text/markdown\", content::SomeType)\n\nIn some cases it may be desireable to specialize lreport_for_show! for MIME types like MIME\"text/html\" and MIME\"text/plain\" as well.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.map_datafiles-Tuple{Any, Any, LegendData, DataCategoryLike, AbstractVector{<:FileKey}}","page":"API","title":"LegendDataManagement.map_datafiles","text":"map_datafiles(\n    f_process, f_open, data::LegendData,\n    category::DataCategoryLike, filekeys::AbstractVector{<:FileKey}\n)\n\nProcesses all filekeys in data for category.\n\nOpens the files using f_open and processes them using f_process.\n\nReturns a @NamedTuple{result::Dict{Filekey}, failed::Dict{Filekey}, success::Bool}:\n\nvalues(result) contains the results f_process(f_open(filename)) for  all filenames referred to by category and filekeys.\nvalues(result) contains the error where processing failed.\nsuccess equals isempty(failed)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.parse_ljlexpr-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.parse_ljlexpr","text":"parse_ljlexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an LEGEND Julia expression and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.parse_lpyexpr-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.parse_lpyexpr","text":"parse_lpyexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an expression compatible with the LEGEND Python software and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.partitioninfo","page":"API","title":"LegendDataManagement.partitioninfo","text":"partitioninfo(data::LegendData, label::Symbol = :default)\n\nReturn cross-period data partitions.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.process_ljlexpr","page":"API","title":"LegendDataManagement.process_ljlexpr","text":"process_ljlexpr(expr::LJlExprLike, f_varsubst = identity)::LJlExprLike\n\nVerify that expr is a valid LEGEND Julia expression and return it, with modifications if necessary.\n\nOptionally substitute variables in expr using f_varsubst.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.pydataprod_config-Tuple{LegendData}","page":"API","title":"LegendDataManagement.pydataprod_config","text":"pydataprod_config(data::LegendData)\n\nGet the Python data production configuration for data.\n\nUse pydataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\npydataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\npydataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.pydataprod_parameters-Tuple{LegendData}","page":"API","title":"LegendDataManagement.pydataprod_parameters","text":"pydataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.read_filekeys-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.read_filekeys","text":"read_filekeys(filename::AbstractString)::AbstractVector{FileKey}\n\nReads a list of FileKey from a text file, one file key per line.\n\nIgnores empty lines. # may be used to start a comment in the file.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.readlprops","page":"API","title":"LegendDataManagement.readlprops","text":"readlprops(filename::AbstractString)\nreadprops(filenames::Vector{<:AbstractString})\n\nRead a PropDict from a file and parse it to Unitful.Quantity and Measurements.Measurement objects.\n\nReturns\n\npd::PropDict with all :val fields converted to Unitful.Quantity objects and all :val fields converted to Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.runinfo-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"API","title":"LegendDataManagement.runinfo","text":"runinfo(data::LegendData, runsel::RunSelLike)::NamedTuple\n\nGet the run information for data in runsel.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.search_disk","page":"API","title":"LegendDataManagement.search_disk","text":"search_disk(::Type{<:DataSelector}, path::AbstractString)\n\nSearch on-disk data for data categories, periods, runs, and filekeys.\n\nExamples:\n\nl200 = LegendData(:l200)\n\nsearch_disk(DataCategory, l200.tier[:raw])\nsearch_disk(DataPeriod, l200.tier[:raw, :cal])\nsearch_disk(DataRun, l200.tier[:raw, :cal, \"p02\"])\nsearch_disk(FileKey, l200.tier[DataTier(:raw), :cal, DataPeriod(2), \"r006\"])\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.start_filekey-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"API","title":"LegendDataManagement.start_filekey","text":"start_filekey(data::LegendData, runsel::RunCategorySelLike)\n\nGet the starting filekey for data in period, run, category.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.tmp_filename-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.tmp_filename","text":"LegendDataManagement.tmp_filename(fname::AbstractString)\n\nReturns a temporary filename, based on fname, in the same directory.\n\nDoes not create the temporary file.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.write_filekeys-Tuple{AbstractString, AbstractVector{<:FileKey}}","page":"API","title":"LegendDataManagement.write_filekeys","text":"write_filekeys(filename::AbstractString, filekeys::AbstractVector{<:FileKey})\n\nWrites a list of FileKey to a text file, one file key per line.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.writelprops","page":"API","title":"LegendDataManagement.writelprops","text":"writelprops(f::IO, p::PropDict; write_units::Bool=true, write_errors::Bool=true, mutliline::Bool=true, indent::Int=4)\nwritelprops(filename::AbstractString, p::PropDict; multiline::Bool=true, indent::Int=4)\nwritelprops(db::PropsDB, key::Union{Symbol, DataSelector}, p::PropDict; kwargs...)\n\nWrite a PropDict to a file and strip it to :val and :unit fields and :val and :err fields.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.writelreport","page":"API","title":"LegendDataManagement.writelreport","text":"writelreport(filename::AbstractString, rpt::LegendReport)\nwritelreport(filename::AbstractString, mime::MIME, rpt::LegendReport)\n\nWrite lreport rpt to file filename.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendDataManagement.jl","page":"Home","title":"LegendDataManagement.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the LEGEND data and metadata management.","category":"page"},{"location":"","page":"Home","title":"Home","text":"======= It requires a central configuration file (see the example \"config.json\" in the LEGEND test data repository). While the path to this configuration file can be specified explicitly, we recommend setting an environment variable named $LEGEND_DATA_CONFIG to the absolute path of your \"config.json\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"LegendDataManagment provides a SolidStateDetectors extension that makes it possible to create SolidStateDetector objects from LEGEND metadata.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Usage examples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LegendDataManagement\nusing PropertyFunctions\n\nl200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nraw_filename = l200.tier[:raw, \"l200-p02-r006-cal-20221226T200846Z\"]\n\nl200.metadata.hardware.detectors.germanium.diodes\n\nchinfo = channel_info(l200, filekey)\nfilterby(@pf $processable && $usability)(chinfo)","category":"page"},{"location":"extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"extensions/#SolidStateDetectors-extension","page":"Extensions","title":"SolidStateDetectors extension","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"LegendDataManagment provides an extension for SolidStateDetectors. This makes it possible to create SolidStateDetector instances from LEGEND metadata.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Example (requires a $LEGEND_DATA_CONFIG environment variable pointing to a legend data-config file):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using LegendDataManagement, SolidStateDetectors, Plots\ndet = SolidStateDetector(LegendData(:l200), :V99000A)\nplot(det)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"A detector can also be constructed using the filename of the LEGEND metadata detector-datasheet JSON file (no $LEGEND_DATA_CONFIG required):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"det = SolidStateDetector(LegendData, \"V99000A.json\")","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The following code will generate an overview plot of every 5th LEGEND detector (requires the actual LEGEND metadata instead of the metadata in legend-testdata):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using LegendDataManagement, SolidStateDetectors, Plots\nl200 = LegendData(:l200)\ndetnames = propertynames(l200.metadata.hardware.detectors.germanium.diodes)\nplot(\n    plot.(SolidStateDetector.(Ref(l200), detnames[1:5:120]))...,\n    layout = (3,8), lw = 0.05, legend = false, grid = false, showaxis = false,\n    xlims = (-0.05,0.05), ylims = (-0.05,0.05), zlims = (0,0.1), size = (4000,1500)\n)","category":"page"}]
}
