var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#LegendDataManagement.AbstractSetupData","page":"API","title":"LegendDataManagement.AbstractSetupData","text":"abstract type AbstractSetupData\n\nSubtypes wrap SetupConfig for specific experiments.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ChannelId","page":"API","title":"LegendDataManagement.ChannelId","text":"struct ChannelId <: DataSelector\n\nRepresents a LEGEND data channel.\n\nExample:\n\nch = ChannelId(1083204)\n# ch = ChannelId(98) # with old channel numbering\nch.no == 1083204\nstring(ch) == \"ch1083204\"\nChannelId(\"ch1083204\") == ch\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataCategory","page":"API","title":"LegendDataManagement.DataCategory","text":"struct DataCategory <: DataSelector\n\nRepresents a LEGEND data category (related to a DAQ/measuring mode) like \"cal\" or \"phy\".\n\nExample:\n\ncategory = DataCategory(:cal)\ncategory.label == :cal\nstring(category) == \"cal\"\nDataCategory(\"cal\") == category\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPartition","page":"API","title":"LegendDataManagement.DataPartition","text":"struct DataPartition <: DataSelector\n\nRepresents a LEGEND data-taking partition.\n\nExample:\n\npartition = DataPartition(1)\npartition.no == 1\nstring(partition) == \"partition01\"\nDataPartition(\"partiton01\") == partition\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPeriod","page":"API","title":"LegendDataManagement.DataPeriod","text":"struct DataPeriod <: DataSelector\n\nRepresents a LEGEND data-taking period.\n\nExample:\n\nperiod = DataPeriod(2)\nperiod.no == 2\nstring(period) == \"p02\"\nDataPeriod(\"p02\") == period\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataRun","page":"API","title":"LegendDataManagement.DataRun","text":"struct DataRun <: DataSelector\n\nRepresents a LEGEND data-taking run.\n\nExample:\n\nr = DataRun(6)\nr.no == 6\nstring(r) == \"r006\"\nDataRun(\"r006\") == r\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataSelector","page":"API","title":"LegendDataManagement.DataSelector","text":"abstract type DataSelector\n\nAbstract type for data selectors like ExpSetup, DataTier, DataPeriod, DataRun, DataCategory, Timestamp and FileKey.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataTier","page":"API","title":"LegendDataManagement.DataTier","text":"struct DataTier <: DataSelector\n\nRepresents a LEGEND data tier like \"raw, \"dsp\", etc.\n\nExample:\n\ntier = DataTier(:raw)\ntier.label == :raw\nstring(tier) == \"raw\"\nDataTier(\"raw\") == tier\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DetectorId","page":"API","title":"LegendDataManagement.DetectorId","text":"struct DetectorId <: DataSelector\n\nRepresents a LEGEND detector id id.\n\nExample:\n\ndetector = DetectorId(:V99000A)\ndetector.label == :V99000A\nstring(detector) == \"V99000A\"\nDetectorId(\"V99000A\") == detector\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ExpSetup","page":"API","title":"LegendDataManagement.ExpSetup","text":"struct ExpSetup <: DataSelector\n\nRepresents a LEGEND experimental setup like \"l200\".\n\nExample:\n\nsetup = ExpSetup(:l200)\nsetup.label == :l200\nstring(setup) == \"l200\"\nExpSetup(\"l200\") == setup\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.FileKey","page":"API","title":"LegendDataManagement.FileKey","text":"struct FileKey <: DataSelector\n\nRepresents a LEGEND file key.\n\nExample:\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nSee also read_filekeys and write_filekeys.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendData","page":"API","title":"LegendDataManagement.LegendData","text":"struct LegendData <: AbstractSetupData\n\nProvides access to LEGEND data and metadata.\n\nConstructors:\n\nLegendData(setup_config::SetupConfig).\nLegendData(setup::Symbol) - requires the $LEGEND_DATA_CONFIG environment variable to be set.\n\nExamples:\n\nconfig_filename = \"/path/to/config.json\"\nconfig = LegendDataConfig(config_filename)\nl200 = LegendData(config.setups.l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nor simply (if $LEGEND_DATA_CONFIG is set):\n\nl200 = LegendData(:l200)\n\nLegendData has the (virtual) properties metadata and tier.\n\nThe full path to \"tier\" data files can be retrieved using\n\n(data::LegendData)[tier::Symbol, filekey::FileKey]\n(data::LegendData).tier[tier::Symbol, filekey::AbstractString]\n\nExample:\n\nl200.tier[:raw]\nl200.tier[:raw, FileKey(\"l200-p02-r006-cal-20221226T200846Z\")]\n\nLegendData comes with an extension for SolidStateDetectors:\n\nl200 = LegendData(:l200)\nSolidStateDetector(l200, :V99000A)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendDataConfig","page":"API","title":"LegendDataManagement.LegendDataConfig","text":"struct LegendDataConfig\n\nData configuration multiple experimental setups.\n\nContains a single field setups::PropertyDict{Symbol,SetupConfig}.\n\nCan be read from a config file via LegendDataConfig(config_filename[s]), or simply LegendDataConfig() if the environment variable $LEGEND_DATA_CONFIG is set. $LEGEND_DATA_CONFIG may be a list of colon-separated config filenames, which are applied/merged in reverse order (analog to the order of prioritiy in $PATH and similar).\n\nExample:\n\nconfig = LegendDataConfig(\"/path/to/config.json\")\nsetup = config.setups.l200\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\nSee also SetupConfig.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendReport","page":"API","title":"LegendDataManagement.LegendReport","text":"struct LegendReport\n\nRepresents a LEGEND report.\n\nDon't instantiate directly, use lreport()\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LegendTierData","page":"API","title":"LegendDataManagement.LegendTierData","text":"struct LegendDataManagement.LegendTierData\n\nConstructors:\n\n(data::LegendData).tier\n\nLegendDataManagement.LegendTierData(data::LegendData)\n\nThe path to data directories and files can be accessed via getindex on tier_data::LegendTierData:\n\ntier_data[]\ntier_data[tier::DataTierLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike]\ntier_data[tier::DataTierLike, category::DataCategoryLike, period::DataPeriodLike, run::DataRunLike, ch::ChannelIdLike]\n\ntier_data[tier::DataTierLike, filekey::FileKeyLike]\ntier_data[tier::DataTierLike, filekey::FileKeyLike, ch::ChannelIdLike]\n\nExamples:\n\n```julia l200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\") isfile(l200.tier[:raw, filekey])\n\nisdir(l200.tier[:raw, :cal]) isdir(l200.tier[:raw, :cal, \"p02\"]) isdir(l200.tier[:raw, :cal, \"p02\", \"r006\"]) isdir(l200.tier[DataTier(:raw), DataCategory(:cal), DataPeriod(2), DataRun(6)])\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.NoSuchPropsDBEntry","page":"API","title":"LegendDataManagement.NoSuchPropsDBEntry","text":"struct LegendDataManagement.NoSuchPropsDBEntry\n\nIndicates that a given property (path) of a LegendDataManagementPropsDB[@ref] does not exist.\n\nSupports PropDicts.writeprops(missing_props::NoSuchPropsDBEntry, props::PropDicts.PropDict) to create the missing directories and file for the property path.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.PeriodSelLike","page":"API","title":"LegendDataManagement.PeriodSelLike","text":"struct PeriodSelLike = Tuple{<:DataPeriodLike, <:DataCategoryLike}\n\nRepresents a LEGEND period selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ProcessStatus","page":"API","title":"LegendDataManagement.ProcessStatus","text":"@enum ProcessStatus\n\nMay be succeeded, pending, or failed.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.PropsDB","page":"API","title":"LegendDataManagement.PropsDB","text":"struct LegendDataManagement.PropsDB\n\nA PropsDB instance, e.g. myprops, presents an on-disk directory containing JSON files or sub-directories (that contains JSON files in leaf directories) as a dictionary of properties.\n\nPropsDB supports Base.keys and Base.getindex as well as Base.propertynames and Base.getproperty to access it's contents. getindex and getproperty will return either another PropsDB or a PropDicts.PropDict, depending on whether the accessed property is stored as a sub-directory or a JSON file. We recommend to use getproperty where the properties/keys of the PropDict are more or less standardized and where they may be arbitrary (see examples below).\n\nThe contents of PropsDB may be time- and category-dependent, determined by the presence of a \"validity.json\" file. In this case, use myprops(sel::LegendDataManagement.ValiditySelection) or myprops(filekey::FileKey) to select the desired time and category. The selection can be made at some point during traversal of properties or at the leaf PropsDB (see the examples below).\n\nExamples:\n\nl200 = LegendData(:l200)\n\npropertynames(l200.metadata.hardware)\nl200.metadata.hardware.detectors.germanium\n\nkeys(l200.metadata.hardware.detectors.germanium.diodes)\nl200.metadata.hardware.detectors.germanium.diodes[:V99000A]\n\ndiodes = l200.metadata.hardware.detectors.germanium.diodes\ndiodes[keys(diodes)]\n\nsel = ValiditySelection(\"20221226T194007Z\", :cal)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T194007Z\")\ndata.metadata.hardware(sel).configuration.channelmaps\ndata.metadata.hardware.configuration.channelmaps(filekey)\n\nUse code should not instantiate PropsDB directly, use  LegendDataManagement.AnyProps(path::AbstractString) instead, which may return a PropsDB or a PropDicts.PropDict depending on what on-disk content path points to. \n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.RunCategorySelLike","page":"API","title":"LegendDataManagement.RunCategorySelLike","text":"struct RunCategorySelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection for a specific category.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.RunSelLike","page":"API","title":"LegendDataManagement.RunSelLike","text":"struct RunSelLike = Tuple{<:DataPeriodLike, <:DataRunLike}\n\nRepresents a LEGEND run selection.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.SetupConfig","page":"API","title":"LegendDataManagement.SetupConfig","text":"struct SetupConfig\n\nData configuration for an experimental setup.\n\nSupports\n\ndata_path(setup, path_components)\n\nExamples:\n\ndata_path(setup, \"tier\", \"raw\", \"cal\", \"p02\", \"r006\", \"l200-p02-r006-cal-20221226T200846Z-tier_raw.lh5\")\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.Timestamp","page":"API","title":"LegendDataManagement.Timestamp","text":"struct Timestamp <: DataSelector\n\nRepresents a LEGEND timestamp.\n\nExample:\n\njulia timestamp = Timestamp(\"20221226T200846Z\") timestamp.unixtime == 1672085326 string(timestamp) == \"20221226T200846Z\"`\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ValiditySelection","page":"API","title":"LegendDataManagement.ValiditySelection","text":"struct LegendDataManagement.ValiditySelection\n\nRepresenty validiy selection for a LegendDataManagement.PropsDB[@ref].\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.AnyProps","page":"API","title":"LegendDataManagement.AnyProps","text":"LegendDataManagement.AnyProps = Union{LegendDataManagement.PropsDB,PropDicts.PropDict}\n\nProperties stored either in a directory managed via [LegendDataManagement.PropsDB][@ref] or loaded from one or several files into a PropDicts.PropDict.\n\nConstructors:\n\nLegendDataManagement.AnyProps(base_path::AbstractString; override_base::AbstractString = \"\")\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.AnyValiditySelection","page":"API","title":"LegendDataManagement.AnyValiditySelection","text":"const AnyValiditySelection = Union{ValiditySelection,FileKey}\n\nAnything that can be used in time/category-based data selection.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ChannelIdLike","page":"API","title":"LegendDataManagement.ChannelIdLike","text":"ChannelIdLike = Union{ChannelId, Integer, AbstractString}\n\nAnything that can represent a data channel, like ChannelId(1083204) or \"ch1083204\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataCategoryLike","page":"API","title":"LegendDataManagement.DataCategoryLike","text":"DataCategoryLike = Union{DataCategory, Symbol, AbstractString}\n\nAnything that can represent a data category, like DataCategory(:cal), :cal or \"cal\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPartitionLike","page":"API","title":"LegendDataManagement.DataPartitionLike","text":"DataPartitionLike = Union{DataPartition, Symbol, AbstractString}\n\nAnything that can represent a data partition, like DataPartition(2) or \"partition02\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataPeriodLike","page":"API","title":"LegendDataManagement.DataPeriodLike","text":"DataPeriodLike = Union{DataPeriod, Symbol, AbstractString}\n\nAnything that can represent a data period, like DataPeriod(2) or \"p02\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataRunLike","page":"API","title":"LegendDataManagement.DataRunLike","text":"DataRunLike = Union{DataRun, Symbol, AbstractString}\n\nAnything that can represent a data run, like DataRun(6) or \"r006\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DataTierLike","page":"API","title":"LegendDataManagement.DataTierLike","text":"DataTierLike = Union{DataTier, Symbol, AbstractString}\n\nAnything that can represent a data tier, like DataTier(:raw), :raw or \"raw\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.DetectorIdLike","page":"API","title":"LegendDataManagement.DetectorIdLike","text":"DetectorIdLike = Union{DetectorId, Symbol, AbstractString}\n\nAnything that can represent a detector id.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.ExpSetupLike","page":"API","title":"LegendDataManagement.ExpSetupLike","text":"ExpSetupLike = Union{ExpSetup, Symbol, AbstractString}\n\nAnything that can represent a setup label, like ExpSetup(:l200), :l200 or \"l200\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.FileKeyLike","page":"API","title":"LegendDataManagement.FileKeyLike","text":"FileKeyLike = Union{FileKey, AbstractString}\n\nAnything that can represent a file key, like FileKey(\"l200-p02-r006-cal-20221226T200846Z\") or \"l200-p02-r006-cal-20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.LJlExprLike","page":"API","title":"LegendDataManagement.LJlExprLike","text":"const LJlExprLike = Union{Expr, Symbol, Integer, AbstractFloat}\n\nAnything that can represent a parsed LEGEND Julia expression.\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.TimestampLike","page":"API","title":"LegendDataManagement.TimestampLike","text":"TimestampLike = Union{Timestamp, AbstractString, Integer}\n\nAnything that can represent a timestamp, like Timestamp(\"20221226T200846Z\") or \"20221226T200846Z\".\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDataManagement.analysis_runs-Tuple{LegendData}","page":"API","title":"LegendDataManagement.analysis_runs","text":"analysis_runs(data::LegendData)\n\nReturn cross-period analysis runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.atomic_fcreate-Tuple{Any, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.atomic_fcreate","text":"function atomic_fcreate(\n    body, filenames::AbstractString...;\n    create_dirs::Bool = true, overwrite::Bool = true, delete_on_error::Bool=true\n)\n\nCreates filenames in an atomic fashion.\n\nCreates temporary files in the same directories as filenames, then calls body(temporary_filenames...). If body returns successfully, the files temporary_filenames are renamed to filenames. If body throws an exception, the temporary files are either deleted (if delete_on_error is true) or left in place (e.g. for debugging purposes).\n\nIf create_dirs is true, directories are created if necessary.\n\nIf all of files already exist and overwrite is false, takes no action (or, if the file is created by other code running in parallel, while body is running, does not overwrite it).\n\nThrows an error if only some of the files exist and overwrite is false.\n\nReturns nothing.\n\nExample:\n\natomic_fcreate(\"foo.txt\", \"bar.txt\") do foo, bar\n    write(foo, \"Hello\")\n    write(bar, \"World\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.bad_filekeys-Tuple{LegendData}","page":"API","title":"LegendDataManagement.bad_filekeys","text":"bad_filekeys(data::LegendData)\n\nGet the list of filekeys to ignore for data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.channelinfo-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.channelinfo","text":"channelinfo(data::LegendData, sel::AnyValiditySelection; system::Symbol = :all, only_processable::Bool = false, only_usability::Symbol = :all, extended::Bool = false)\nchannelinfo(data::LegendData, sel::RunCategorySelLike; system::Symbol = :all, only_processable::Bool = false, only_usability::Symbol = :all, extended::Bool = false)\n\nGet all channel information for the given LegendData and ValiditySelection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path","page":"API","title":"LegendDataManagement.data_path","text":"data_path(setup::SetupConfig, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\nConverts between \"/\" and \"\\\" inside of path_components if necessary (for Windows compatibility).\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.AbstractSetupData, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(setup::AbstractSetupData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components as configured for setup.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.LegendTierData, Vararg{AbstractString}}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(tier_data::LegendTierData, path_components::AbstractString...)\n\nGet the full absolute path for the given path_components relative to tier_data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.data_path-Tuple{LegendDataManagement.PropsDB}","page":"API","title":"LegendDataManagement.data_path","text":"data_path(pd::LegendDataManagement.PropsDB)\n\nReturn the path to the data directory that contains pd.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_config-Tuple{LegendData}","page":"API","title":"LegendDataManagement.dataprod_config","text":"dataprod_config(data::LegendData)\n\nGet the Julia data production configuration for data.\n\nUse dataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\ndataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\ndataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_parameters-Tuple{LegendData}","page":"API","title":"LegendDataManagement.dataprod_parameters","text":"dataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_pars_aoe_window-Tuple{LegendData, AnyValiditySelection, DetectorId, Symbol}","page":"API","title":"LegendDataManagement.dataprod_pars_aoe_window","text":"LegendDataManagement.dataprod_pars_aoe_window(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the A/E cut window for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.dataprod_pars_lq_window-Tuple{LegendData, AnyValiditySelection, DetectorId, Symbol}","page":"API","title":"LegendDataManagement.dataprod_pars_lq_window","text":"LegendDataManagement.dataprod_pars_lq_window(data::LegendData, sel::AnyValiditySelection, detector::DetectorId, lq_classifier::Symbol; pars_type::Symbol=:ppars, pars_cat::Symbol=:lq)\n\nGet the LQ cut window for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.find_filekey","page":"API","title":"LegendDataManagement.find_filekey","text":"find_filekey(ds::DataSet, ts::TimestampLike)\nfind_filekey(data::LegendData, ts::TimestampLike; kwargs...)\n\nFind the filekey in a dataset that is closest to a given timestamp. The kwargs are passed to search_disk to generate the DataSet.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_aux_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_aux_cal_propfunc","text":"get_aux_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the aux calibration function for the given data, validity selection and the aux channel referred to by detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_aux_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_aux_evt_chdata_propfunc","text":"get_aux_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the aux channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_aux_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_aux_evt_chsel_propfunc","text":"get_aux_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the aux channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_aux_evt_levelname_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_aux_evt_levelname_propfunc","text":"get_aux_evt_levelname_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the aux event level name.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_exposure-Tuple{LegendData, DetectorIdLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}}","page":"API","title":"LegendDataManagement.get_exposure","text":"get_exposure(data::LegendData, det::DetectorIdLike, period::DataPeriodLike, run::DataRunLike; kwargs...)\nget_exposure(data::LegendData, det::DetectorIdLike, period::DataPeriodLike; kwargs...)\nget_exposure(data::LegendData, det::DetectorIdLike, partition::DataPartitionLike; kwargs...)\n\nCalculates the exposure of a detector in a given run/period/partition.\n\nArguments\n\ndata: LegendData object with information on detector geometries and runinfo / partitioninfo\ndet Detector for which the exposure is calculated\nperiod: DataPeriod for which the exposure is calculated\nrun: DataRun for which the exposure is calculated\npartition: DataPartition for which the exposure is calculated\n\nKeyword Arguments\n\nis_analysis_run: If set to true, only the runs flagged as is_analysis_phy_tun == true are considered. Default is true.\ncat DataCategory for which the exposure is calculated. Default is :phy.`\n\nReturns\n\nexposure: the exposure of the detector det for the time given.\n\nExample\n\njulia l200 = LegendData(:l200) get_exposure(l200, :V00050A, DataPeriod(3), DataRun(0)) get_exposure(l200, :V00050A, DataPeriod(3)) get_exposure(l200, :V00050A, DataPartition(1))`\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_aoe_cut_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_aoe_cut_propfunc","text":"LegendDataManagement.get_ged_aoe_cut_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId; pars_type::Symbol=:ppars, pars_cat::Symbol=:aoe)\n\nGet the A/E cut propfuncs for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_cal_propfunc","text":"get_ged_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the HPGe calibration function for the given data, validity selection and detector.\n\nNote: Caches configuration/calibration data internally, use a fresh data object if on-disk configuration/calibration data may have changed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_chdata_propfunc","text":"get_ged_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the Ge-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_chsel_propfunc","text":"get_ged_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the Ge-detector channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_hitchsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_hitchsel_propfunc","text":"get_ged_evt_hitchsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the hit Ge-detector channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_is_valid_hit_properties-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_is_valid_hit_properties","text":"get_ged_evt_is_valid_hit_properties(data::LegendData, sel::AnyValiditySelection)\n\nGet the hit Ge-detector is_valid_hit selection properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_evt_kwargs-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_ged_evt_kwargs","text":"get_ged_evt_kwargs(data::LegendData, sel::AnyValiditySelection)\n\nGet the Ge-detector evt kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_lq_cut_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_lq_cut_propfunc","text":"LegendDataManagement.get_ged_lq_cut_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId; pars_type::Symbol=:ppars, pars_cat::Symbol=:lq)\n\nGet the LQ cut propfuncs for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_psd_classifier_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_psd_classifier_propfunc","text":"get_ged_psd_classifier_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PSD cut propfuncs for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_psd_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_psd_propfunc","text":"get_ged_psd_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId; pars_type::Symbol=:ppars, pars_cat::Symbol=:aoe)\n\nGet the HPGe psd calibration function for the given data, validity selection and detector.\n\nNote: Caches configuration/calibration data internally, use a fresh data object if on-disk configuration/calibration data may have changed.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_cuts_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_cuts_propfunc","text":"get_ged_qc_cuts_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector QC cut definitions for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_is_baseline_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_is_baseline_propfunc","text":"get_ged_qc_is_baseline_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet a PropertyFunction that returns true for events that fullfill the is_baseline definition.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_is_physical_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_is_physical_propfunc","text":"get_ged_qc_is_physical_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet a PropertyFunction that returns true for events that fullfill the is_physical definition.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_ged_qc_is_trig_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_ged_qc_is_trig_propfunc","text":"get_ged_qc_istrig_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the Ge-detector trigger condition for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_partition_combined_periods-Tuple{LegendData, DataPeriodLike}","page":"API","title":"LegendDataManagement.get_partition_combined_periods","text":"get_partition_combined_periods(data::LegendData, period::DataPeriodLike; chs::Vector{ChannelIdLike}=ChannelIdLike[])\n\nGet a list periods which are combined in any partition for the given period and list of channels.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmt_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_pmt_cal_propfunc","text":"get_pmt_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the PMT calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmt_is_physical_trig_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_pmt_is_physical_trig_propfunc","text":"get_pmt_is_physical_trig_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the PMT physical trigger condition for the given data and validity selection.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_chdata_propfunc","text":"get_pmts_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_chsel_propfunc","text":"get_pmts_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_evtdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_evtdata_propfunc","text":"get_pmts_evt_evtdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_kwargs-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_kwargs","text":"get_pmts_evt_kwargs(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT evt kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_pmts_evt_muon_cut_props-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_pmts_evt_muon_cut_props","text":"get_pmts_evt_muon_cut_props(data::LegendData, sel::AnyValiditySelection)\n\nGet the PMT muon cut properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_setup_config","page":"API","title":"LegendDataManagement.get_setup_config","text":"LegendDataManagement.get_setup_config(data::AbstractSetupData)::SetupConfig\n\nMust be specialized for each subtype of AbstractSetupData.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_spm_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_spm_cal_propfunc","text":"get_spm_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spm_dc_cal_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_spm_dc_cal_propfunc","text":"get_spm_dc_cal_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS DC calibration function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spm_dc_sel_propfunc-Tuple{LegendData, AnyValiditySelection, DetectorId}","page":"API","title":"LegendDataManagement.get_spm_dc_sel_propfunc","text":"get_spm_dc_sel_propfunc(data::LegendData, sel::AnyValiditySelection, detector::DetectorId)\n\nGet the LAr/SPMS DC calibration selector function for the given data, validity selection and detector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_chdata_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_chdata_propfunc","text":"get_spms_evt_chdata_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM-detector channel data output PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_chsel_propfunc-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_chsel_propfunc","text":"get_spms_evt_chsel_propfunc(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM channel selection PropertyFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_kwargs-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_kwargs","text":"get_spms_evt_kwargs(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM-detector evt kwargs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_spms_evt_lar_cut_props-Tuple{LegendData, AnyValiditySelection}","page":"API","title":"LegendDataManagement.get_spms_evt_lar_cut_props","text":"get_spms_evt_lar_cut_props(data::LegendData, sel::AnyValiditySelection)\n\nGet the SiPM LAr cut properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.get_uncertainties","page":"API","title":"LegendDataManagement.get_uncertainties","text":"get_uncertainties(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_uncertainties(x::Unitful.Quantity{<:Real})\nget_uncertainties(pd::PropDict)\nget_uncertainties(A::AbstractArray)\n\nGet the uncertainty of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.get_values","page":"API","title":"LegendDataManagement.get_values","text":"get_values(x::Unitful.Quantity{<:Measurements.Measurement{<:Real}})\nget_values(x::Unitful.Quantity{<:Real})\nget_values(pd::PropDict)\nget_values(A::AbstractArray)\n\nGet the value of a Unitful.Quantity or Measurements.Measurement object or a PropDict or an array of Unitful.Quantity or Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.is_analysis_cal_run-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}}}","page":"API","title":"LegendDataManagement.is_analysis_cal_run","text":"is_analysis_cal_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike))\n\nReturn true if run is an analysis run for data in period. \n\nATTENTION: This is only valid for cal runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.is_analysis_phy_run-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}}}","page":"API","title":"LegendDataManagement.is_analysis_phy_run","text":"is_analysis_phy_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike))\n\nReturn true if run is an analysis run for data in period. \n\nATTENTION: This is only valid for phy runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.is_analysis_run","page":"API","title":"LegendDataManagement.is_analysis_run","text":"is_analysis_run(data::LegendData, (period::DataPeriodLike, run::DataRunLike, cat::DataCategoryLike))\n\nReturn true if run is an cat analysis run for data in period.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.is_lrun-Tuple{LegendData, Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}}","page":"API","title":"LegendDataManagement.is_lrun","text":"is_lrun(data::LegendData, runsel::RunSelLike)\n\nReturn true if runsel is a valid run for data and therefore appears in the metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.livetime","page":"API","title":"LegendDataManagement.livetime","text":"livetime(data::LegendData, runsel::RunSelLike)\n\nGet the livetime for data in physics data taking of run in period.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.ljl_propfunc","page":"API","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr::LJlExprLike)\nljl_propfunc(expr_string::AbstractString)\n\nCompiles a PropertyFunctions.PropertyFunction from a LEGEND Julia expression.\n\nSee also parse_lpyexpr.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.ljl_propfunc-Tuple{AbstractDict{Symbol, <:Union{AbstractFloat, Expr, Integer, Symbol}}}","page":"API","title":"LegendDataManagement.ljl_propfunc","text":"ljl_propfunc(expr_map::AbstractDict{Symbol,<:LJlExprLike})\nljl_propfunc(expr_map::AbstractDict{Symbol,<:AbstractString})\nljl_propfunc(expr_map::PropDict)\n\nCompiles a map between output field-names and LEGEND Julia expressions to a single PropertyFunctions.PropertyFunction.\n\nThe generated function will return NamedTuples with the same property names as the keys of expr_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.lpy_propfunc-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.lpy_propfunc","text":"lpy_propfunc(expr_string::AbstractString)::PropertyFunctions.PropertyFunction\n\nGenerate a PropertyFunctions.PropertyFunction from a LEGEND Python expression.\n\nSee also parse_lpyexpr and ljl_propfunc.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.lreport","page":"API","title":"LegendDataManagement.lreport","text":"lreport()\nlreport(contents...)\n\nGenerate a LEGEND report, e.g. a data processing report.\n\nUse lreport!(rpt, contents...) to add more content to a report.\n\nExample:\n\nusing LegendDataManagement, StructArrays, IntervalSets, Plots\n\ntbl = StructArray(\n    col1 = rand(5), col2 = ClosedInterval.(rand(5), rand(5).+1),\n    col3 = [rand(3) for i in 1:5], col4 = ProcessStatus.(rand(-1:1, 5)),\n    col5 = [:a, :b, :c, :d, :e], col6 = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    col7 = [:(a[1]), :(a[2]), :(a[3]), :(a[4]), :(a[5])]\n)\n\nrpt = lreport(\n    \"# New report\",\n    \"Table 1:\", tbl\n)\nlreport!(rpt, \"Figure 1:\", stephist(randn(10^3)))\nlreport!(rpt, \"Figure 2:\", histogram2d(randn(10^4), randn(10^4), format = :png))\n\nshow(stdout, MIME\"text/plain\"(), rpt)\nshow(stdout, MIME\"text/html\"(), rpt)\nshow(stdout, MIME\"text/markdown\"(), rpt)\n\nwritelreport(\"report.txt\", rpt)\nwritelreport(\"report.html\", rpt)\nwritelreport(\"report.md\", rpt)\n\nSee LegendDataManagement.lreport_for_show! for how to specialize the behavior of show for specific report content types.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.lreport!","page":"API","title":"LegendDataManagement.lreport!","text":"lreport!(rpt::LegendReport, contents...)\n\nAdd more content to report rpt. See lreport for an example.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.lreport_for_show!","page":"API","title":"LegendDataManagement.lreport_for_show!","text":"LegendDataManagement.lreport_for_show!(rpt::LegendReport, mime::MIME, content)\n\nAdd the contents of content to rpt in a way that is optimized for being displayed (e.g. via show) with the given mime type.\n\nshow(output, mime, rpt) first transforms rpt by converting all contents of rpt using lreport_for_show!(rpt::LegendReport, mime, content).\n\nDefaults to lreport!(rpt, content), except for tables (Tables.istable(content) == true), which are converted to Markdown tables by default for uniform appearance.\n\nlreport_for_show! is not inteded to be called by users, but to be specialized for specific types of content content. Content types not already supported will primarily require specialization of\n\nlreport_for_show!(rpt::LegendReport, ::MIME\"text/markdown\", content::SomeType)\n\nIn some cases it may be desireable to specialize lreport_for_show! for MIME types like MIME\"text/html\" and MIME\"text/plain\" as well.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.map_datafiles-Tuple{Any, Any, LegendData, DataCategoryLike, AbstractVector{<:FileKey}}","page":"API","title":"LegendDataManagement.map_datafiles","text":"map_datafiles(\n    f_process, f_open, data::LegendData,\n    category::DataCategoryLike, filekeys::AbstractVector{<:FileKey}\n)\n\nProcesses all filekeys in data for category.\n\nOpens the files using f_open and processes them using f_process.\n\nReturns a @NamedTuple{result::Dict{Filekey}, failed::Dict{Filekey}, success::Bool}:\n\nvalues(result) contains the results f_process(f_open(filename)) for  all filenames referred to by category and filekeys.\nvalues(result) contains the error where processing failed.\nsuccess equals isempty(failed)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.parse_ljlexpr-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.parse_ljlexpr","text":"parse_ljlexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an LEGEND Julia expression and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.parse_lpyexpr-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.parse_lpyexpr","text":"parse_lpyexpr(expr_string::AbstractString)::LJlExprLike\n\nParse an expression compatible with the LEGEND Python software and return a Julia syntax tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.partitioninfo","page":"API","title":"LegendDataManagement.partitioninfo","text":"partitioninfo(data::LegendData, ch::ChannelId)::IdDict{DataPartition, Table}\n\npartitioninfo(data::LegendData, ch::ChannelId, part::DataPartitionLike; category::DataCategoryLike=:all)\npartitioninfo(data::LegendData, ch::ChannelId, period::DataPeriodLike; category::DataCategoryLike=:all)\npartitioninfo(data, ch, period::DataPeriodLike, run::DataRunLike; category::DataCategoryLike=:all)\n\nReturn cross-period data partitions.\n\n# Arguments\n- `data::LegendData`: The LegendData object containing the data.\n- `ch::ChannelId`: The channel identifier.\n\n# Returns\n- `IdDict{DataPartition, Table}`: A dictionary mapping data partitions to tables.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.process_ljlexpr","page":"API","title":"LegendDataManagement.process_ljlexpr","text":"process_ljlexpr(expr::LJlExprLike, f_varsubst = identity)::LJlExprLike\n\nVerify that expr is a valid LEGEND Julia expression and return it, with modifications if necessary.\n\nOptionally substitute variables in expr using f_varsubst.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.pydataprod_config-Tuple{LegendData}","page":"API","title":"LegendDataManagement.pydataprod_config","text":"pydataprod_config(data::LegendData)\n\nGet the Python data production configuration for data.\n\nUse pydataprod_config(data)(valsel::AnyValiditySelection) to also set the time/category validity selection for the configuration.\n\nExamples:\n\nl200 = LegendData(:l200)\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\npydataprod_config(l200)(filekey)\n\nor\n\nl200 = LegendData(:l200)\nvsel = ValiditySelection(\"20221226T200846Z\", :cal)\npydataprod_config(l200)(vsel)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.pydataprod_parameters-Tuple{LegendData}","page":"API","title":"LegendDataManagement.pydataprod_parameters","text":"pydataprod_parameters(data::LegendData)\n\nGet the Julia data production parameters data.\n\nExamples:\n\nl200 = LegendData(:l200)\ndataprod_config(l200)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.read_filekeys-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.read_filekeys","text":"read_filekeys(filename::AbstractString)::AbstractVector{FileKey}\n\nReads a list of FileKey from a text file, one file key per line.\n\nIgnores empty lines. # may be used to start a comment in the file.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.read_ldata","page":"API","title":"LegendDataManagement.read_ldata","text":"read_ldata(data::LegendData, selectors...; kwargs...)\nread_ldata(f, data::LegendData, selectors...; kwargs...)\nread_ldata(columns::NTuple{<:Any, Symbol}, data::LegendData, selectors::Tuple; kwargs...)\nread_ldata(column::Symbol, data::LegendData, selectors::Tuple; kwargs...)\n\nRead lh5 data from disk for a given set of selectors. After reading in, a PropertyFunction f can be applied to the data.  If a tuple of Symbols is given, the properties from the tuple are selected. If the n_evts kwarg is provided, a random selection with n_evts number of events per file is performed. ch can be either a ChannelId or a DetectorId.\n\nExamples\n\ndsp = read_ldata(l200, :jldsp, filekey, ch)\ndsp = read_ldata((:e_cusp, :e_trap, :blmean), l200, :jldsp, filekey, ch)\ndsp = read_ldata(:e_cusp, l200, :jldsp, filekey, ch)\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, ch)\n\ndsp = read_ldata(l200, :jldsp, :cal, DataPartition(1), ch)\ndsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch)\ndsp = read_ldata(l200, :jldsp, :cal, runinfo(l200)[1:3], ch)\n\ndsp = read_ldata(l200, :jldsp, filekey, ch; n_evts=1000)\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.readlprops","page":"API","title":"LegendDataManagement.readlprops","text":"readlprops(filename::AbstractString)\nreadprops(filenames::Vector{<:AbstractString})\n\nRead a PropDict from a file and parse it to Unitful.Quantity and Measurements.Measurement objects.\n\nReturns\n\npd::PropDict with all :val fields converted to Unitful.Quantity objects and all :val fields converted to Measurements.Measurement objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.runinfo-Tuple{LegendData}","page":"API","title":"LegendDataManagement.runinfo","text":"runinfo(data::LegendData)::Table\nruninfo(data::LegendData, runsel::RunSelLike)::NamedTuple\nruninfo(data::LegendData, filekey::FileKey)::NamedTuple\n\nGet the run information for data.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.search_disk","page":"API","title":"LegendDataManagement.search_disk","text":"search_disk(::Type{<:DataSelector}, path::AbstractString)\nsearch_disk(::Type{DataSet}, data::LegendData; search_categories::Vector{<:DataCategoryLike} = DataCategory.([:cal, :phy]), search_tier::DataTierLike = DataTier(:raw), only_analysis_runs::Bool=true, save_filekeys::Bool=true, ignore_save_tier::Bool=false, save_tier::DataTierLike=DataTier(:jlfks))\n\nSearch on-disk data for data categories, periods, runs, and filekeys or whole datasets If you want to search for a whole DataSet, you have the following keyword options:     - search_categories (default: [:cal, :phy]): The categories to search on disk.     - search_tier (default: DataTier(:raw)): The tier to search on disk.     - only_analysis_runs (default: true): Only include for analysis runs as defined in the metadata     - save_filekeys (default: true): Save the filekeys to a file in the save_tier directory.     - ignore_save_tier (default: false): Ignore the save_tier and do not save the filekeys.     - save_tier (default: DataTier(:jlfks)): The tier to save the filekeys to.\n\nExamples:\n\nl200 = LegendData(:l200)\n\nsearch_disk(DataCategory, l200.tier[:raw])\nsearch_disk(DataPeriod, l200.tier[:raw, :cal])\nsearch_disk(DataRun, l200.tier[:raw, :cal, \"p02\"])\nsearch_disk(FileKey, l200.tier[DataTier(:raw), :cal, DataPeriod(2), \"r006\"])\nsearch_disk(DataSet, l200)\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.start_filekey","page":"API","title":"LegendDataManagement.start_filekey","text":"start_filekey(data::LegendData, runsel::RunCategorySelLike)\n\nGet the starting filekey for data in period, run, category.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.tmp_filename-Tuple{AbstractString}","page":"API","title":"LegendDataManagement.tmp_filename","text":"LegendDataManagement.tmp_filename(fname::AbstractString)\n\nReturns a temporary filename, based on fname, in the same directory.\n\nDoes not create the temporary file.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.write_filekeys-Tuple{AbstractString, AbstractVector{<:FileKey}}","page":"API","title":"LegendDataManagement.write_filekeys","text":"write_filekeys(filename::AbstractString, filekeys::AbstractVector{<:FileKey})\n\nWrites a list of FileKey to a text file, one file key per line.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.writelprops","page":"API","title":"LegendDataManagement.writelprops","text":"writelprops(f::IO, p::PropDict; write_units::Bool=true, write_errors::Bool=true, mutliline::Bool=true, indent::Int=4)\nwritelprops(filename::AbstractString, p::PropDict; multiline::Bool=true, indent::Int=4)\nwritelprops(db::PropsDB, key::Union{Symbol, DataSelector}, p::PropDict; kwargs...)\n\nWrite a PropDict to a file and strip it to :val and :unit fields and :val and :err fields.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.writelreport","page":"API","title":"LegendDataManagement.writelreport","text":"writelreport(filename::AbstractString, rpt::LegendReport)\nwritelreport(filename::AbstractString, mime::MIME, rpt::LegendReport)\n\nWrite lreport rpt to file filename.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.channel2detector-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.channel2detector","text":"channel2detector(data::LegendData, sel::Union{AnyValiditySelection, RunCategorySelLike}, channel::ChannelIdLike)\n\nGet the DetectorId for a given ChannelId input: \n\ndata, e.g. LegendData(:l200)`\nrunsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\nchannel: ChannelId e.g. ChannelId(1080005)`\n\noutput:\n\nDetectorId of corresponding channel\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.create_logtbl-Tuple{Any}","page":"API","title":"LegendDataManagement.LDMUtils.create_logtbl","text":"create_logtbl(result)\n\nCreate a log table for a given result which can be added in a report.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.create_metadatatbl","page":"API","title":"LegendDataManagement.LDMUtils.create_metadatatbl","text":"create_metadatatbl(filekey::FileKey)\ncreate_metadatatbl(filekey::FileKey, part::DataPartitionLike)\n\nCreate a metadata table for a given filekey which can be added in a report.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.create_pars-Tuple{PropDicts.PropDict, Any}","page":"API","title":"LegendDataManagement.LDMUtils.create_pars","text":"create_pars(pd::PropDict, result::Dict{ChannelInfo, ChannelResult}) -> PropDict\n\nCreate a PropDict from a result of the parallel processing\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.create_validity-Tuple{Any}","page":"API","title":"LegendDataManagement.LDMUtils.create_validity","text":"create_validity(result) -> StructArray\n\nCreate a StructArray from a result of the parallel processing\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.data_starttime-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}}","page":"API","title":"LegendDataManagement.LDMUtils.data_starttime","text":"data_starttime(data::LegendData, runsel::Union{AnyValiditySelection, RunCategorySelLike})\n\nExtract startime as DateTime from file for a given run selection     Input:     * data: LegendData, e.g. LegendData(:l200)     * runsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.detector2channel-Tuple{LegendData, Union{Tuple{DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike}, AnyValiditySelection}, DetectorIdLike}","page":"API","title":"LegendDataManagement.LDMUtils.detector2channel","text":"detector2channel(data::LegendData, sel::Union{AnyValiditySelection, RunCategorySelLike}, detector::DetectorIdLike)\n\nGet the ChannelId for a given detectorId  input: \n\ndata, e.g. LegendData(:l200)`\nrunsel: runselection, e.g. (DataPeriod(3), DataRun(0), :cal)\ndetector: DetectorID e.g. DetectorId(:P00573A)OR ChannelID e.g.ChannelId(1080005)``\n\noutput:\n\nChannelId of corresponding detector\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.detector_type-Tuple{LegendData, DetectorIdLike}","page":"API","title":"LegendDataManagement.LDMUtils.detector_type","text":"get_det_type(data::LegendData, det::DetectorIdLike)\n\nLooks up the detector type for a given DetectorID.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_hitchfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.get_hitchfilename","text":"get_hitchfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_hitchfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the hitch data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_mltrainfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_mltrainfilename","text":"get_mltrainfilename(data::LegendData, period::DataPeriodLike, category::DataCategoryLike)\nget_mltrainfilename(data::LegendData, filekey::FileKey)\n\nGet the filename for the machine learning training data.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_partitionfilekeys-Tuple{LegendData, DataPartitionLike, DataTierLike, DataCategoryLike}","page":"API","title":"LegendDataManagement.LDMUtils.get_partitionfilekeys","text":"get_partitionfilekeys(data::LegendData, part::DataPartitionLike, tier::DataTierLike, category::DataCategoryLike; only_good::Bool=true)\n\nGet filekeys for a given partition.\n\nArguments\n\ndata::LegendData: data object\npart::DataPartitionLike: partition to be searched in\ntier::DataTierLike: tier\ncategory::DataCategoryLike: category\nonly_good::Bool=true: only get good filekeys\n\nReturn\n\nVector{FileKey}: filekeys\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_partitionvalidity","page":"API","title":"LegendDataManagement.LDMUtils.get_partitionvalidity","text":"get_partitionvalidity(data::LegendData, ch::ChannelIdLike, part::DataPartitionLike, cat::DataCategoryLike=:cal) -> Vector{@NamedTuple{period::DataPeriod, run::DataRun, validity::String}}\n\nGet partition validity for a given channel and partition.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_peaksfilename-Tuple{LegendData, ExpSetupLike, DataPeriodLike, Union{DataRun, AbstractString, Symbol}, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.get_peaksfilename","text":"get_peaksfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike)\nget_peaksfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike)\n\nGet the filename for the peaks data for a given channel.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.get_plottitle","page":"API","title":"LegendDataManagement.LDMUtils.get_plottitle","text":"get_plottitle(setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, det::DetectorIdLike, process::AbstractString; additional_type::AbstractString=\"\")\nget_plottitle(filekey::FileKey, det::DetectorIdLike, process::AbstractString; kwargs...)\nget_plottitle(setup::ExpSetupLike, partition::DataPartitionLike, category::DataCategoryLike, det::DetectorIdLike, process::AbstractString; additional_type::AbstractString=\"\")\nget_plottitle(filekey::FileKey, partition::DataPartitionLike, det::DetectorIdLike, process::AbstractString; kwargs...)\n\nGet the title for a plot.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_pltfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_pltfilename","text":"get_pltfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol)\nget_pltfilename(data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol)\n\nGet the filename for the plot file for a given setup, period, run, category, channel and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_pltfolder","page":"API","title":"LegendDataManagement.LDMUtils.get_pltfolder","text":"get_pltfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\nget_pltfolder(data::LegendData, filekey::FileKey, process::Symbol)\nget_pltfolder(data::LegendData, partition::DataPartitionLike, category::DataCategoryLike, process::Symbol, ch::ChannelIdOrDetectorIDLike)\n\nGet the folder for the plot files for a given period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_preportfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_preportfilename","text":"get_preportfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, category::DataCategoryLike, process::Symbol)\n\nGet the filename for the log file for a given setup, period, category and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_preportfolder","page":"API","title":"LegendDataManagement.LDMUtils.get_preportfolder","text":"get_preportfolder(data::LegendData, period::DataPeriodLike, category::DataCategoryLike)\n\nGet the preport folder for the log files for a given period and category.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_rreportfilename","page":"API","title":"LegendDataManagement.LDMUtils.get_rreportfilename","text":"get_rreportfilename(data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, process::Symbol)\nget_rreportfilename(data::LegendData, filekey::FileKey, process::Symbol)\n\nGet the filename for the log file for a given setup, period, run, category and process.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_rreportfolder","page":"API","title":"LegendDataManagement.LDMUtils.get_rreportfolder","text":"get_rreportfolder(data::LegendData, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike)\n\nGet the rreport folder for the log files for a given period, run and category.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.get_totalTimer-Tuple{Vector}","page":"API","title":"LegendDataManagement.LDMUtils.get_totalTimer","text":"get_totalTimer(result::Vector)\n\nGet the total timer from a result vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.load_partition_ch-Tuple{Function, Function, LegendData, TypedTables.Table, DataTierLike, DataCategoryLike, Union{Int64, ChannelId, AbstractString}}","page":"API","title":"LegendDataManagement.LDMUtils.load_partition_ch","text":"load_partition_ch(open_func::Function, flatten_func::Function, data::LegendData, partinfo::StructVector, tier::DataTierLike, cat::DataCategoryLike, ch::ChannelIdLike; data_keys::Tuple=(), n_evts::Int=-1, select_random::Bool=false)\nload_partition_ch(open_func::Function, flatten_func::Function, data::LegendData, part::DataPartition, tier::DataTierLike, cat::DataCategoryLike, ch::ChannelIdLike; kwargs...)\n\nLoad data for a channel from a partition. \n\nArguments\n\nopen_func::Function: function to open a file\nflatten_func::Function: function to flatten data\ndata::LegendData: data object\npartinfo::StructVector: partition info\ntier::DataTierLike: tier\ncat::DataCategoryLike: category\nch::ChannelIdLike: channel\ndata_keys::Tuple=(): data keys, empty tuple selects all keys\nn_evts::Int=-1: number of events, -1 selects all events\nselect_random::Bool=false: select events randomly\n\nReturn\n\nTable: data table with flattened events\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDataManagement.LDMUtils.load_raw_evt","page":"API","title":"LegendDataManagement.LDMUtils.load_raw_evt","text":"load_raw_evt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::Int)\nload_raw_evt(open_func::Function, data::LegendData, ch::ChannelIdLike, data_hit::Table, sel_evt::UnitRange{Int})\n\nLoad data for a channel from a hitch file for a given selected event index or index range.\n\nArguments\n\nopen_func::Function: function to open a file\ndata::LegendData: data object\nch::ChannelIdLike: channel\ndata_hit::Table: hitch data\nsel_evt::Int/UnitRange{Int}: selected event index\n\nReturn\n\nTable: data table of raw events\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.load_run_ch","page":"API","title":"LegendDataManagement.LDMUtils.load_run_ch","text":"load_run_ch(open_func::Function, flatten_func::Function, data::LegendData, filekeys::Vector{FileKey}, tier::DataTierLike, ch::ChannelIdLike; check_filekeys::Bool=true)\n\nLoad data for a channel from a list of filekeys in a given tier.\n\nArguments\n\nopen_func::Function: function to open a file\nflatten_func::Function: function to flatten data\ndata::LegendData: data object\nfilekeys::Vector{FileKey}: list of filekeys\ntier::DataTierLike: tier to load data from\nch::ChannelIdLike: channel to load data for\ncheck_filekeys::Bool=true: check if filekeys are valid\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.savelfig","page":"API","title":"LegendDataManagement.LDMUtils.savelfig","text":"savelfig(save_func::Function, p, data::LegendData, setup::ExpSetupLike, period::DataPeriodLike, run::DataRunLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, filekey::FileKey, ch::ChannelIdLike, process::Symbol; kwargs...)\nsavelfig(save_func::Function, p, data::LegendData, partition::DataPartitionLike, setup::ExpSetupLike, category::DataCategoryLike, ch::ChannelIdLike, process::Symbol; kwargs...)\n\nSave a lplot.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDataManagement.LDMUtils.writevalidity","page":"API","title":"LegendDataManagement.LDMUtils.writevalidity","text":"writevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey; category::Symbol=:all)\nwritevalidity(props_db::LegendDataManagement.PropsDB, filekey::FileKey, part::DataPartitionLike; category::Symbol=:all)\n\nWrite validity for a given filekey.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendDataManagement.jl","page":"Home","title":"LegendDataManagement.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a Julia implementation of the LEGEND data and metadata management.","category":"page"},{"location":"","page":"Home","title":"Home","text":"======= It requires a central configuration file (see the example \"config.json\" in the LEGEND test data repository). While the path to this configuration file can be specified explicitly, we recommend setting an environment variable named $LEGEND_DATA_CONFIG to the absolute path of your \"config.json\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"LegendDataManagment provides a SolidStateDetectors extension that makes it possible to create SolidStateDetector objects from LEGEND metadata.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Usage examples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LegendDataManagement\nusing PropertyFunctions\n\nl200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p02-r006-cal-20221226T200846Z\")\n\nraw_filename = l200.tier[:raw, \"l200-p02-r006-cal-20221226T200846Z\"]\n\nl200.metadata.hardware.detectors.germanium.diodes\n\nchinfo = channel_info(l200, filekey)\nfilterby(@pf $processable && $usability)(chinfo)","category":"page"},{"location":"extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"extensions/#Plots-extension","page":"Extensions","title":"Plots extension","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"LegendDataManagment provides an extension for Plots. This makes it possible to directly plot LEGEND data via the plot function. The extension is automatically loaded when both packages are loaded. You can plot a parameter overview as a 2D plot over a set of detectors (requires a $LEGEND_DATA_CONFIG environment variable pointing to a legend data-config file):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using LegendDataManagement, Plots\n\nl200 = LegendData(:l200)\n\nfilekey = FileKey(\"l200-p03-r000-cal-20230311T235840Z\")\n\npars = l200.par.ppars.ecal(filekey)\nproperties = [:e_cusp_ctc, :fwhm, :qbb];\n\nchinfo = channelinfo(l200, filekey; system = :geds, only_processable = true)\n\nplot(chinfo, pars, properties, verbose = true, color = 1, markershape = :o, calculate_mean = true)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The plot recipe takes three arguments:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"chinfo: the channel info with all detectors to be plotted on the x-axis\npars: a PropDict that has the detector IDs as keys and parameters as values\nproperties: an array of Symbols to access the data that should be plotted","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"(if no properties are provided, the PropDict pars is expected to just contain the data to be plotted as values)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"There are also keyword arguments:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"calculate_mean: If set to true, then the mean values are included in the legend labels. For values with uncertainties, the mean values are calculated as weighted means.\nverbose: some output when the plot is generated, e.g. if values for (some) detectors are missing","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"A 3D plot is WIP.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In addition, you can plot an event display of the raw waveforms:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using Unitful, LegendDataManagement, Plots\n\nl200 = LegendData(:l200)\n\nts = 1.6785791257987175e9u\"s\"\n\nch = ChannelId(1104000)\n\nplot(l200, ts, ch)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"plot_tier: The data tier to be plotted. Default is DataTier(:raw).\nplot_waveform: All waveforms to be plotted from the data. Default is [:waveform_presummed] which plots the presummed waveform.\nshow_unixtime: If set to true, use unix time instead of the datetime in the title. Default is false.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"If the channel is not given, the recipe automtically searches for the correct event in the data.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"ts = 1.6785791257987175e9u\"s\"\n\nplot(l200, ts)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In case of a cal event, only the HPGe channel with that event is plotted. In case of a phy event, all waveforms of the full HPGe and SiPM systems are plotted.  The following additional keywords arguments can be set (the plot_waveform kwarg is replaced by the system kwarg here):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"system: The system and the waveforms to be plotted for each system. Default is Dict{Symbol, Vector{Symbol}}([:geds, :spms] .=> [[:waveform_presummed], [:waveform_bit_drop]])\nonly_processable: If set to true, only processable channels are plotted. Default is true.","category":"page"},{"location":"extensions/#LegendHDF5IO-extension","page":"Extensions","title":"LegendHDF5IO extension","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"LegendDataManagment provides an extension for LegendHDF5IO. This makes it possible to directly load LEGEND data from HDF5 files via the read_ldata function. The extension is automatically loaded when both packages are loaded.  Example (requires a $LEGEND_DATA_CONFIG environment variable pointing to a legend data-config file):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using LegendDataManagement, LegendHDF5IO\nl200 = LegendData(:l200)\nfilekeys = search_disk(FileKey, l200.tier[:jldsp, :cal, :p03, :r000])\n\nchinfo = channelinfo(l200, (:p03, :r000, :cal); system=:geds, only_processable=true)\n\nch = chinfo[1].channel\n\ndsp = read_ldata(l200, :jldsp, first(filekeys), ch)\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, ch)\ndsp = read_ldata((:e_cusp, :e_trap, :blmean, :blslope), l200, :jldsp, :cal, :p03, :r000, ch)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"read_ldata automitcally loads LEGEND data for a specific DataTier and data selection like e.g. a FileKey or a run-selection based for a given ChannelId. The search_disk function allows the user to search for available DataTier and FileKey on disk. The first argument can be either a selection of keys in form of a NTuple of Symbol or a PropertyFunction which will be applied during loading.  It is also possible to load whole a DataPartition or DataPeriod for a given ChannelId ch:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"dsp = read_ldata(l200, :jldsp, :cal, DataPartition(1), ch)\ndsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In additon, it is possible to load a random selection of n_evts events randomly selected from each loaded file:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"dsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, ch; n_evts=1000)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"For simplicity, the ch can also be given as a DetectorID which will be converted internally to a ChannelId:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"det = chinfo[1].detector\ndsp = read_ldata(l200, :jldsp, :cal, :p03, :r000, det)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In case, a ChannelId is missing in a file, the function will throw an ArgumentError. To avoid this and return nothing instead, you can use the ignore_missing keyword argument.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"It is possible to read in multiple files in parallel using the Distributed functionalities from within a session. You can activate parallel read with the parallel kwarg.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"dsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch)\ndsp = read_ldata(l200, :jldsp, :cal, DataPeriod(3), ch; parallel=true)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"However, it is necessary that a worker allocation was already performed and the LegendDataManagement as well as LegendHDF5IO package is loaded on all workers, e.g. with","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using Distributed\naddprocs(4)\n@everywhere using LegendDataManagement, LegendHDF5IO","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In addition, the wpoolkwarg allows to parse a custome WorkerPool for more sophisticated load patterns.","category":"page"},{"location":"extensions/#SolidStateDetectors-extension","page":"Extensions","title":"SolidStateDetectors extension","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"LegendDataManagment provides an extension for SolidStateDetectors. This makes it possible to create SolidStateDetector and Simulation instances from LEGEND metadata.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Example (requires a $LEGEND_DATA_CONFIG environment variable pointing to a legend data-config file):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using LegendDataManagement, SolidStateDetectors, Plots\ndet = SolidStateDetector(LegendData(:l200), :V99000A)\nplot(det)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"st = :slice keyword can be passed to the plot to plot a 2D slice of the detector. Using the previous constructor looks up the diode and crystal metadata files and calls the following lower level constructor – which can also be used directly (no $LEGEND_DATA_CONFIG required):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"det = SolidStateDetector(LegendData, \"V99000A.yaml\", \"V99000.yaml\")","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In cases where multiple values (or none) are available in the metadata, the detector is configured using the following priority:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"n⁺ contact thickness: 0νββ analysis value (if available) → manufacturer's value (if available) → default value\nOperational Voltage: l200 characterization value (if available) → manufacturer's value (if available) → default value\nImpurity profile: model in crystal metadata (if available) → constant value of 0","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"In addition, when creating a Simulation, all simulation functions in SolidStateDetectors.jl can be applied. As usual, all fields stored in the Simulation can be written and read using LegendHDF5IO:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using LegendDataManagement\nusing SolidStateDetectors\n\nsim = Simulation(LegendData, \"V99000A.yaml\", \"V99000.yaml\")\nsimulate!(sim) # calculate electric field and weighting potentials\n\nusing LegendHDF5IO\nssd_write(\"V99000A.lh5\", sim)\nsim_in = ssd_read(\"V99000A.lh5\", Simulation)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The following code will generate an overview plot of every 5th LEGEND detector (requires the actual LEGEND metadata instead of the metadata in legend-testdata):","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"using LegendDataManagement, SolidStateDetectors, Plots\nl200 = LegendData(:l200)\ndetnames = propertynames(l200.metadata.hardware.detectors.germanium.diodes)\nplot(\n    plot.(SolidStateDetector.(Ref(l200), detnames[1:5:120]))...,\n    layout = (3,8), lw = 0.05, legend = false, grid = false, showaxis = false,\n    xlims = (-0.05,0.05), ylims = (-0.05,0.05), zlims = (0,0.1), size = (4000,1500)\n)","category":"page"}]
}
